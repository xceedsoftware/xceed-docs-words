"use strict";(self.webpackChunkxceed_docs_words=self.webpackChunkxceed_docs_words||[]).push([[4785],{74253:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>m,contentTitle:()=>d,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var t=s(74848),a=s(28453),n=s(11470),o=s(19365);const i={title:"Decompressing a stream"},d="Decompressing stream data",c={id:"code-snippets/memory-decompression/decompressing-stream",title:"Decompressing a stream",description:"This topic demonstrates how to decompress data that is read from a Stream to a MemoryStream using the XceedCompressedStream class.",source:"@site/zip/code-snippets/memory-decompression/decompressing-stream.md",sourceDirName:"code-snippets/memory-decompression",slug:"/code-snippets/memory-decompression/decompressing-stream",permalink:"/xceed-docs-words/zip/code-snippets/memory-decompression/decompressing-stream",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Decompressing a stream"},sidebar:"sidebarzip",previous:{title:"Memory decompression",permalink:"/xceed-docs-words/zip/category/memory-decompression"},next:{title:"Decompressing a memory buffer (QuickCompression)",permalink:"/xceed-docs-words/zip/code-snippets/memory-decompression/decompressing-memory-buffer"}},m={},l=[{value:"Basic steps",id:"basic-steps",level:2},{value:"Example",id:"example",level:2},{value:"Things you should consider",id:"things-you-should-consider",level:2}];function u(e){const r={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"decompressing-stream-data",children:"Decompressing stream data"})}),"\n",(0,t.jsxs)(r.p,{children:["This topic demonstrates how to decompress data that is read from a Stream to a ",(0,t.jsx)(r.code,{children:"MemoryStream"})," using the ",(0,t.jsx)(r.code,{children:"XceedCompressedStream"})," class."]}),"\n",(0,t.jsxs)(r.p,{children:["Although we are using a ",(0,t.jsx)(r.code,{children:"MemoryStream"})," as our source and a ",(0,t.jsx)(r.code,{children:"FileStream"})," as our destination, we could have also used any other type of stream. For example, we could have decompressed data read from a ",(0,t.jsx)(r.code,{children:"FileStream"})," to another ",(0,t.jsx)(r.code,{children:"FileStream"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"basic-steps",children:"Basic steps"}),"\n",(0,t.jsx)(r.p,{children:"To decompress data that is read from a stream, the following steps must be taken:"}),"\n",(0,t.jsx)(r.p,{children:"1- Obtain the source stream from data will be read. This can be any Stream object from any source (file, memory, network, whatever) as long as data can be read from it. No 'seek' or 'write' capabilities are needed. It is assumed that the stream will contain compressed data produced by XceedCompressedStream."}),"\n",(0,t.jsxs)(r.p,{children:["2- Create a XceedCompressedStream around the source stream. For the purposes of this example we used the XceedCompressedStream class. However, we could have also used the ",(0,t.jsx)(r.code,{children:"GZipCompressedStream"})," or the ",(0,t.jsx)(r.code,{children:"ZLibCompressedStream"})," classes."]}),"\n",(0,t.jsx)(r.p,{children:"3- Create the destination stream to which the decompressed data will be written. For the purposes of this example, our destination stream will be a MemoryStream."}),"\n",(0,t.jsx)(r.p,{children:"4- Read the data from the XceedCompressedStream. Reading from a compressed stream means that the data is automatically decompressed as it is read from its inner stream."}),"\n",(0,t.jsx)(r.p,{children:"5- Write the decompressed data to the destination stream."}),"\n",(0,t.jsx)(r.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(r.p,{children:"The following example demonstrates how to read compressed data from a MemoryStream and decompress it to a FileStream using the XceedCompressedStream class."}),"\n",(0,t.jsxs)(n.A,{children:[(0,t.jsx)(o.A,{value:"csharp",label:"C#",default:!0,children:(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-csharp",children:"  using Xceed.Compression;\r\n  using Xceed.Compression.Formats;\r\n\r\n  namespace FileSystemDocumentationExamples.CompressionComponent\r\n  {\r\n    public class DecompressXceedCompressedStreamExample\r\n    {\r\n      public void MyMainMethod()\r\n      {\r\n        /* Because Xceed.Compression.Formats is an optional assembly not automatically\r\n          unlocked by Xceed Zip for .NET, we must explicitly set our license key to it\r\n          before use or else an exception will be thrown. */\r\n        Xceed.Compression.Formats.Licenser.LicenseKey = \"<your Xceed Zip for .NET license key>\";\r\n      }\r\n\r\n      public void Example( Stream compressedData )\r\n      {\r\n        /* 'compressedData' is assumed to contain the compressed data produced by XceedCompressedStream\r\n          This can be any Stream object from any source (file, memory, network, whatever) as\r\n          long as data can be read from it. No 'seek' or 'write' capabilities are needed.\r\n        \r\n          In the special case where 'compressedData' is the same Stream object that has been\r\n          used as the destination stream for compression, the stream's position will need to be\r\n          changed to the start of the compressed data. Otherwise, no compressed data will be\r\n          found since the stream will be positioned at the end of the compressed data. */\r\n\r\n\r\n        /* With XceedCompressedStream, the compression method of the compressed data is\r\n          contained as part of the compressed stream. This is convenient as we don't need\r\n          to remember the value. */\r\n\r\n        // Optional: If the data was encrypted, supply the password\r\n        string password = String.Empty;\r\n        password = \"password\";\r\n\r\n        // Create a XceedCompressedStream that wraps around our compressed source data\r\n        using( XceedCompressedStream xceedCompressedStream = new XceedCompressedStream( compressedData, password ) )\r\n        {\r\n          /* The XceedCompressedStream automatically closes the destination\r\n            stream. So there is no need to declare the stream within a using\r\n            statement or to call Close() once we are done with the stream.\r\n              \r\n            If you do not want the inner stream to be closed by the XceedCompressedStream,\r\n            set its Transient property to true. */\r\n\r\n          // Optional: Prevent XceedCompressedStream from closing 'destinationStream' automatically\r\n          //xceedCompressedStream.Transient = true;\r\n\r\n          byte[] uncompressedData = null;\r\n\r\n          /* Setup a destination stream. This can be any Stream object for any destination as\r\n            long as data can be written to it. No 'seek' or 'read' capabilities are needed. */\r\n          using( MemoryStream destinationStream = new MemoryStream() )\r\n          {\r\n            int bytesRead;\r\n\r\n            // Setup a 32K buffer\r\n            byte[] buffer = new byte[ 32 * 1024 ];\r\n\r\n            // Read from the source stream until there is no more data, this will decompress the data\r\n            while( ( bytesRead = xceedCompressedStream.Read( buffer, 0, buffer.Length ) ) > 0 )\r\n            {\r\n              // Compress the data by writing into the compressed stream\r\n              // Compressed data will be written into its InnerStream, in our case, 'destinationStream'\r\n              destinationStream.Write( buffer, 0, bytesRead );\r\n            }\r\n\r\n            /* Optional: The MemoryStream's compressed data can be copied to a byte array, you can use\r\n              MemoryStream.ToArray(). The method works even when the memory stream has been closed. */\r\n            uncompressedData = destinationStream.ToArray();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\n"})})}),(0,t.jsx)(o.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-vb.NET",children:"Imports Xceed.Compression\r\nImports Xceed.Compression.Formats\r\n\r\nNamespace FileSystemDocumentationExamples.CompressionComponent\r\n  Public Class DecompressXceedCompressedStreamExample\r\n    Public Sub MyMainMethod()\r\n'       Because Xceed.Compression.Formats is an optional assembly not automatically\r\n'         unlocked by Xceed Zip for .NET, we must explicitly set our license key to it\r\n'         before use or else an exception will be thrown. \r\n      Xceed.Compression.Formats.Licenser.LicenseKey = \"<your Xceed Zip for .NET license key>\"\r\n    End Sub\r\n\r\n    Public Sub Example(ByVal compressedData As Stream)\r\n'       'compressedData' is assumed to contain the compressed data produced by XceedCompressedStream\r\n'         This can be any Stream object from any source (file, memory, network, whatever) as\r\n'         long as data can be read from it. No 'seek' or 'write' capabilities are needed.\r\n'       \r\n'         In the special case where 'compressedData' is the same Stream object that has been\r\n'         used as the destination stream for compression, the stream's position will need to be\r\n'         changed to the start of the compressed data. Otherwise, no compressed data will be\r\n'         found since the stream will be positioned at the end of the compressed data. \r\n\r\n\r\n'       With XceedCompressedStream, the compression method of the compressed data is\r\n'         contained as part of the compressed stream. This is convenient as we don't need\r\n'         to remember the value. \r\n\r\n      ' Optional: If the data was encrypted, supply the password\r\n      Dim password As String = String.Empty\r\n      password = \"password\"\r\n\r\n      ' Create a XceedCompressedStream that wraps around our compressed source data\r\n      Using xceedCompressedStream As New XceedCompressedStream(compressedData, password)\r\n'         The XceedCompressedStream automatically closes the destination\r\n'           stream. So there is no need to declare the stream within a using\r\n'           statement or to call Close() once we are done with the stream.\r\n'            \r\n'           If you do not want the inner stream to be closed by the XceedCompressedStream,\r\n'           set its Transient property to true. \r\n\r\n        ' Optional: Prevent XceedCompressedStream from closing 'destinationStream' automatically\r\n        'xceedCompressedStream.Transient = true;\r\n\r\n        Dim uncompressedData() As Byte = Nothing\r\n\r\n'         Setup a destination stream. This can be any Stream object for any destination as\r\n'           long as data can be written to it. No 'seek' or 'read' capabilities are needed. \r\n        Using destinationStream As New MemoryStream()\r\n          Dim bytesRead As Integer\r\n\r\n          ' Setup a 32K buffer\r\n          Dim buffer(32 * 1024 - 1) As Byte\r\n\r\n          ' Read from the source stream until there is no more data, this will decompress the data\r\n          bytesRead = xceedCompressedStream.Read(buffer, 0, buffer.Length)\r\n          Do While bytesRead > 0\r\n            ' Compress the data by writing into the compressed stream\r\n            ' Compressed data will be written into its InnerStream, in our case, 'destinationStream'\r\n            destinationStream.Write(buffer, 0, bytesRead)\r\n            bytesRead = xceedCompressedStream.Read(buffer, 0, buffer.Length)\r\n          Loop\r\n\r\n'           Optional: The MemoryStream's compressed data can be copied to a byte array, you can use\r\n'             MemoryStream.ToArray(). The method works even when the memory stream has been closed. \r\n          uncompressedData = destinationStream.ToArray()\r\n        End Using\r\n      End Using\r\n    End Sub\r\n  End Class\r\nEnd Namespace\n"})})})]}),"\n",(0,t.jsx)(r.h2,{id:"things-you-should-consider",children:"Things you should consider"}),"\n",(0,t.jsx)(r.p,{children:"The main questions you should ask yourself when decompressing data read from a stream are:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["Do you want to prevent the inner stream from being closed when the ",(0,t.jsx)(r.code,{children:"XceedCompressedStream"})," is closed? Set the Transient property of the ",(0,t.jsx)(r.code,{children:"XceedCompressedStream"})," class to true."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["Do you want to decompress data compressed using the GZip or ZLib compression formats? Use the ",(0,t.jsx)(r.code,{children:"GZipCompressedStream"})," or the ",(0,t.jsx)(r.code,{children:"ZLibCompressedStream"})," classes instead of the ",(0,t.jsx)(r.code,{children:"XceedCompressedStream"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["Do you want to decompress data that was compressed without a compression format (raw data)? Use the ",(0,t.jsx)(r.code,{children:"CompressedStream"})," class."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["Do you only want a quick and easy way to decompress a compressed byte array? Use the static ",(0,t.jsx)(r.code,{children:"Decompress"})," method of the desired compression format class."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},19365:(e,r,s)=>{s.d(r,{A:()=>o});s(96540);var t=s(34164);const a={tabItem:"tabItem_Ymn6"};var n=s(74848);function o(e){let{children:r,hidden:s,className:o}=e;return(0,n.jsx)("div",{role:"tabpanel",className:(0,t.A)(a.tabItem,o),hidden:s,children:r})}},11470:(e,r,s)=>{s.d(r,{A:()=>C});var t=s(96540),a=s(34164),n=s(23104),o=s(56347),i=s(205),d=s(57485),c=s(31682),m=s(70679);function l(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:r,children:s}=e;return(0,t.useMemo)((()=>{const e=r??function(e){return l(e).map((e=>{let{props:{value:r,label:s,attributes:t,default:a}}=e;return{value:r,label:s,attributes:t,default:a}}))}(s);return function(e){const r=(0,c.XI)(e,((e,r)=>e.value===r.value));if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[r,s])}function p(e){let{value:r,tabValues:s}=e;return s.some((e=>e.value===r))}function h(e){let{queryString:r=!1,groupId:s}=e;const a=(0,o.W6)(),n=function(e){let{queryString:r=!1,groupId:s}=e;if("string"==typeof r)return r;if(!1===r)return null;if(!0===r&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:r,groupId:s});return[(0,d.aZ)(n),(0,t.useCallback)((e=>{if(!n)return;const r=new URLSearchParams(a.location.search);r.set(n,e),a.replace({...a.location,search:r.toString()})}),[n,a])]}function b(e){const{defaultValue:r,queryString:s=!1,groupId:a}=e,n=u(e),[o,d]=(0,t.useState)((()=>function(e){let{defaultValue:r,tabValues:s}=e;if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!p({value:r,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${r}" but none of its children has the corresponding value. Available values are: ${s.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return r}const t=s.find((e=>e.default))??s[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:r,tabValues:n}))),[c,l]=h({queryString:s,groupId:a}),[b,f]=function(e){let{groupId:r}=e;const s=function(e){return e?`docusaurus.tab.${e}`:null}(r),[a,n]=(0,m.Dv)(s);return[a,(0,t.useCallback)((e=>{s&&n.set(e)}),[s,n])]}({groupId:a}),y=(()=>{const e=c??b;return p({value:e,tabValues:n})?e:null})();(0,i.A)((()=>{y&&d(y)}),[y]);return{selectedValue:o,selectValue:(0,t.useCallback)((e=>{if(!p({value:e,tabValues:n}))throw new Error(`Can't select invalid tab value=${e}`);d(e),l(e),f(e)}),[l,f,n]),tabValues:n}}var f=s(92303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=s(74848);function S(e){let{className:r,block:s,selectedValue:t,selectValue:o,tabValues:i}=e;const d=[],{blockElementScrollPositionUntilNextRender:c}=(0,n.a_)(),m=e=>{const r=e.currentTarget,s=d.indexOf(r),a=i[s].value;a!==t&&(c(r),o(a))},l=e=>{let r=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const s=d.indexOf(e.currentTarget)+1;r=d[s]??d[0];break}case"ArrowLeft":{const s=d.indexOf(e.currentTarget)-1;r=d[s]??d[d.length-1];break}}r?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":s},r),children:i.map((e=>{let{value:r,label:s,attributes:n}=e;return(0,w.jsx)("li",{role:"tab",tabIndex:t===r?0:-1,"aria-selected":t===r,ref:e=>d.push(e),onKeyDown:l,onClick:m,...n,className:(0,a.A)("tabs__item",y.tabItem,n?.className,{"tabs__item--active":t===r}),children:s??r},r)}))})}function x(e){let{lazy:r,children:s,selectedValue:n}=e;const o=(Array.isArray(s)?s:[s]).filter(Boolean);if(r){const e=o.find((e=>e.props.value===n));return e?(0,t.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:o.map(((e,r)=>(0,t.cloneElement)(e,{key:r,hidden:e.props.value!==n})))})}function g(e){const r=b(e);return(0,w.jsxs)("div",{className:(0,a.A)("tabs-container",y.tabList),children:[(0,w.jsx)(S,{...r,...e}),(0,w.jsx)(x,{...r,...e})]})}function C(e){const r=(0,f.A)();return(0,w.jsx)(g,{...e,children:l(e.children)},String(r))}},28453:(e,r,s)=>{s.d(r,{R:()=>o,x:()=>i});var t=s(96540);const a={},n=t.createContext(a);function o(e){const r=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(n.Provider,{value:r},e.children)}}}]);