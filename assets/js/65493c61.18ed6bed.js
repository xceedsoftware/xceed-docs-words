"use strict";(self.webpackChunkxceed_libs_doc=self.webpackChunkxceed_libs_doc||[]).push([[8724],{65397:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>u});var l=t(74848),n=t(28453),a=t(11470),i=t(19365);const s={},o="NameFilter",d={id:"basic-concepts/filters/namefilter-class",title:"NameFilter",description:"The NameFilter class can be used to filter files and folders according to their names.",source:"@site/ftp/basic-concepts/filters/namefilter-class.md",sourceDirName:"basic-concepts/filters",slug:"/basic-concepts/filters/namefilter-class",permalink:"/xceed-libs-doc/ftp/basic-concepts/filters/namefilter-class",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebarftp",previous:{title:"DateTimeFilter",permalink:"/xceed-libs-doc/ftp/basic-concepts/filters/datetime-filter-class"},next:{title:"NotFilter",permalink:"/xceed-libs-doc/ftp/basic-concepts/filters/notfilter-class"}},c={},u=[{value:"Case sensitivity",id:"case-sensitivity",level:2},{value:"Demonstration",id:"demonstration",level:2},{value:"Things you should consider",id:"things-you-should-consider",level:2}];function F(e){const r={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(r.header,{children:(0,l.jsx)(r.h1,{id:"namefilter",children:"NameFilter"})}),"\n",(0,l.jsxs)(r.p,{children:["The ",(0,l.jsx)(r.code,{children:"NameFilter"})," class can be used to filter files and folders according to their names."]}),"\n",(0,l.jsx)(r.h2,{id:"case-sensitivity",children:"Case sensitivity"}),"\n",(0,l.jsx)(r.p,{children:"When using NameFilter classes, by default, case sensitivity is not enforced. In order to enforce case sensitivity, a greater-than symbol (>) must be used as the first character of the string. For example:"}),"\n",(0,l.jsxs)(a.A,{children:[(0,l.jsx)(i.A,{value:"csharp",label:"C#",default:!0,children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-csharp",children:'  AbstractFile[] files = myFolder.GetFiles( true, ">*.TXT" );\r\n  AbstractFile[] files = myFolder.GetFiles( true, ">*.txt|*.exe" );\n'})})}),(0,l.jsx)(i.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-vb.NET",children:'  Dim files As AbstractFile() = myFolder.GetFiles( True, ">*.TXT" )\r\n  Dim files As AbstractFile() = myFolder.GetFiles( True, ">*.txt|*.exe" ) \n'})})})]}),"\n",(0,l.jsx)(r.h2,{id:"demonstration",children:"Demonstration"}),"\n",(0,l.jsxs)(r.p,{children:["Process all files that have the TXT extension. Since, by default, the ",(0,l.jsx)(r.code,{children:"FilterScope"})," enumeration is set to ",(0,l.jsx)(r.strong,{children:"File"}),' and we are using "*.txt" as the filter, there is no need to implicitly set the FilterScope enumeration in the constructor of the NameFilter class.']}),"\n",(0,l.jsxs)(a.A,{children:[(0,l.jsx)(i.A,{value:"csharp",label:"C#",default:!0,children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-csharp",children:'  AbstractFile[] files = myFolder.GetFiles( true, new NameFilter( "*.txt" ) );\n'})})}),(0,l.jsx)(i.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-vb.NET",children:'  Dim files As AbstractFile() = myFolder.GetFiles( True, New NameFilter( "*.txt" ) )\n'})})})]}),"\n",(0,l.jsx)(r.p,{children:"Since we are using a basic string filter, the NameFilter class is used by default, therefore we can omit the creation of a new NameFilter class and simply use a basic filter."}),"\n",(0,l.jsxs)(a.A,{children:[(0,l.jsx)(i.A,{value:"csharp",label:"C#",default:!0,children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-csharp",children:'  AbstractFile[] files = myFolder.GetFiles( true, "*.txt" );\n'})})}),(0,l.jsx)(i.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-vb.NET",children:'  Dim files As AbstractFile() = myFolder.GetFiles( True, "*.txt" )\n'})})})]}),"\n",(0,l.jsx)(r.p,{children:"Process all files that have either the TXT or EXE extension."}),"\n",(0,l.jsxs)(a.A,{children:[(0,l.jsx)(i.A,{value:"csharp",label:"C#",default:!0,children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-csharp",children:'  AbstractFile[] files = myFolder.GetFiles( true, new OrFilter( new NameFilter( "*.txt" ), new NameFilter( "*.exe" ) ) );\n'})})}),(0,l.jsx)(i.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-vb.NET",children:'  Dim files As AbstractFile() = myFolder.GetFiles( True, New OrFilter( New NameFilter( "*.txt" ), New NameFilter( "*.exe" ) ) )\n'})})})]}),"\n",(0,l.jsx)(r.p,{children:"It is possible to simplify the above example by using the pipe (|) character to separate the two strings. The pipe character servers the same purpose as the OrFilter class and removes the necessity of creating two instances of the NameFilter class and regrouping them within an OrFilter class."}),"\n",(0,l.jsxs)(a.A,{children:[(0,l.jsx)(i.A,{value:"csharp",label:"C#",default:!0,children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-csharp",children:'  AbstractFile[] files = myFolder.GetFiles( true, new NameFilter( "*.txt|*.exe" ) );\n'})})}),(0,l.jsx)(i.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-vb.NET",children:'  Dim files As AbstractFile() = myFolder.GetFiles( True, New NameFilter( "*.txt|*.exe" ) )\n'})})})]}),"\n",(0,l.jsx)(r.p,{children:"Here are more complex examples"}),"\n",(0,l.jsxs)(a.A,{children:[(0,l.jsx)(i.A,{value:"csharp",label:"C#",default:!0,children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-csharp",children:'  /*\r\n  * Consider the following folder and file hierarchy:\r\n  * \r\n  * Folder: NameFilter1\r\n  * |-------\x3e Folder: Folder1\r\n  *           |-------\x3e Folder: TargetName\r\n  *                     |-------\x3e Folder: TargetNameAndExtraChars\r\n  *                               |-------\x3e File: File1.dat\r\n  *                               |-------\x3e File: File2.dat\r\n  *                               |-------\x3e File: TargetName.dat\r\n  *                               |-------\x3e File: TargetName\r\n  * |-------\x3e Folder: TargetName\r\n  * \r\n  * |-------\x3e Folder: Folder3\r\n  *           |-------\x3e Folder: Folder3_1\r\n  *                     |-------\x3e Folder: TargetName\r\n  *                               |-------\x3e Folder: Folder3_1_1\r\n  *                                         |-------\x3e Folder: TargetName\r\n  *                                                   |-------\x3e File: File3.dat\r\n  *                                                   |-------\x3e File: File4.dat\r\n  *                               |-------\x3e File: File5.dat\r\n  * |-------\x3e File: File6.dat\r\n  * |-------\x3e File: File7.dat\r\n  * \r\n  * Suppose our goal is to select all folders (not files) that bear the name \'TargetName\',\r\n  * then the folders:\r\n  * \r\n  * NameFilter1->Folder1->TargetName\r\n  * NameFilter1->TargetName\r\n  * NameFilter1->Folder3->Folder3_1->TargetName\r\n  * NameFilter1->Folder3->Folder3_1->TargetName->Folder3_1_1->TargetName\r\n  * \r\n  * should be selected. The \'TargetNameAndExtraChars\' folder is not an exact match and the file\r\n  * \'TargetName\' is a file not a folder.\r\n  * \r\n  * The \'TargetName\' folder under \'Folder3_1_1\' is an interesting case because it is below a\r\n  * previous matched folder. That may or may not be desired. We can address both situations.\r\n  */\r\n\r\n  AbstractFolder baseFolder = new DiskFolder( @"NameFilter1" );\r\n\r\n  // This is the name we will be looking for\r\n  string targetName = "TargetName";\r\n\r\n  // If our test folders don\'t exist\r\n  if( !baseFolder.Exists )\r\n  {\r\n    /* We will create a set of files and folders to test our filter */\r\n\r\n    AbstractFile sourceFile, file;\r\n    AbstractFolder folder;\r\n\r\n    file = baseFolder.GetFile( @"File6.dat" );\r\n    file.Create();\r\n    file = baseFolder.GetFile( @"File7.dat" );\r\n    file.Create();\r\n\r\n    sourceFile = file;\r\n\r\n    folder = baseFolder.GetFolder( string.Format( @"Folder1\\{0}\\{0}AndExtraChars", targetName ) );\r\n    sourceFile.CopyTo( folder.GetFile( "File1.dat" ), true );\r\n    sourceFile.CopyTo( folder.GetFile( "File2.dat" ), true );\r\n    sourceFile.CopyTo( folder.GetFile( targetName + ".dat" ), true );\r\n    sourceFile.CopyTo( folder.GetFile( targetName ), true );\r\n\r\n    folder = baseFolder.GetFolder( targetName );\r\n    folder.Create();\r\n\r\n    folder = baseFolder.GetFolder( string.Format( @"Folder3\\Folder3_1\\{0}", targetName ) );\r\n    sourceFile.CopyTo( folder.GetFile( "File5.dat" ), true );\r\n    folder = folder.GetFolder( string.Format( @"Folder3_1_1\\{0}", targetName ) );\r\n    sourceFile.CopyTo( folder.GetFile( "File3.dat" ), true );\r\n    sourceFile.CopyTo( folder.GetFile( "File4.dat" ), true );\r\n  }\r\n\r\n  AbstractFolder[] folders;\r\n  AbstractFile[] files;\r\n\r\n  /*\r\n  * The simplest approach is use a NameFilter object and set the scope to FilterScope.Folder.\r\n  * This will select all the folders that have our targetName.\r\n  * \r\n  * The key is the FilterScope argument set to Folder */\r\n\r\n  // Create a name filter that accepts our targetName on a folder only (case insensitive)\r\n  NameFilter nameFilter = new NameFilter( targetName, FilterScope.Folder );\r\n\r\n  // Get any folder that match our name filter\r\n  folders = baseFolder.GetFolders( true, nameFilter );\r\n\r\n  Console.WriteLine( "Simple filtering" );\r\n  foreach( AbstractFolder folder in folders )\r\n  {\r\n    Console.WriteLine( folder.FullName );\r\n  }\r\n  Console.WriteLine();\r\n\r\n  /* The output will be:\r\n  * NameFilter1->Folder1->TargetName\r\n  * NameFilter1->TargetName\r\n  * NameFilter1->Folder3->Folder3_1->TargetName\r\n  * NameFilter1->Folder3->Folder3_1->TargetName->Folder3_1_1->TargetName\r\n\r\n\r\n  /*\r\n  * If you only want the most top level folder that matches the filter and not any sub folders\r\n  * that also match the filter, you can add filters that exclude them.\r\n  * \r\n  * The key is to prevent the filtering engine to recurse into folders that match our tagetName.\r\n  * Again, the FilterScope parameter can be put to good use.\r\n  */\r\n\r\n  // Create a name filter that matches the name \'Aid\' but only when determining if the\r\n  // filter engine should look into a recursed folder\r\n  NameFilter recurseFilter = new NameFilter( targetName, FilterScope.Recurse );\r\n\r\n  // Wrap our recurse filter in a NotFilter to invert the decision\r\n  NotFilter notFilter = new NotFilter( recurseFilter );\r\n\r\n  // Get all the folders that match our name and do not match the name when recursing into sub folders\r\n  folders = baseFolder.GetFolders( true, nameFilter, notFilter );\r\n\r\n  Console.WriteLine( "Filtering with only top-level matches" );\r\n  foreach( AbstractFolder folder in folders )\r\n  {\r\n    Console.WriteLine( folder.FullName );\r\n\r\n    /* TODO: Here, you can process all the files that are in the folder individually\r\n        with folder.GetFiles() or as a group using methods like folder.CopyFilesTo(), etc */\r\n  }\r\n  Console.WriteLine();\r\n\r\n  /******************************/\r\n\r\n  /* If you\'re simply looking for files */\r\n\r\n  // Get all the files that match our name (this works because by default, the FilterScore is for files only)\r\n  files = baseFolder.GetFiles( true, targetName );\r\n\r\n  Console.WriteLine( "Filtering for files only" );\r\n  foreach( AbstractFile file in files )\r\n  {\r\n    Console.WriteLine( file.FullName );\r\n  }\r\n  Console.WriteLine();\n'})})}),(0,l.jsx)(i.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-vb.NET",children:"  '      \r\n  '       * Consider the following folder and file hierarchy:\r\n  '       * \r\n  '       * Folder: NameFilter1\r\n  '       * |-------\x3e Folder: Folder1\r\n  '       *           |-------\x3e Folder: TargetName\r\n  '       *                     |-------\x3e Folder: TargetNameAndExtraChars\r\n  '       *                               |-------\x3e File: File1.dat\r\n  '       *                               |-------\x3e File: File2.dat\r\n  '       *                               |-------\x3e File: TargetName.dat\r\n  '       *                               |-------\x3e File: TargetName\r\n  '       * |-------\x3e Folder: TargetName\r\n  '       * \r\n  '       * |-------\x3e Folder: Folder3\r\n  '       *           |-------\x3e Folder: Folder3_1\r\n  '       *                     |-------\x3e Folder: TargetName\r\n  '       *                               |-------\x3e Folder: Folder3_1_1\r\n  '       *                                         |-------\x3e Folder: TargetName\r\n  '       *                                                   |-------\x3e File: File3.dat\r\n  '       *                                                   |-------\x3e File: File4.dat\r\n  '       *                               |-------\x3e File: File5.dat\r\n  '       * |-------\x3e File: File6.dat\r\n  '       * |-------\x3e File: File7.dat\r\n  '       * \r\n  '       * Suppose our goal is to select all folders (not files) that bear the name 'TargetName',\r\n  '       * then the folders:\r\n  '       * \r\n  '       * NameFilter1->Folder1->TargetName\r\n  '       * NameFilter1->TargetName\r\n  '       * NameFilter1->Folder3->Folder3_1->TargetName\r\n  '       * NameFilter1->Folder3->Folder3_1->TargetName->Folder3_1_1->TargetName\r\n  '       * \r\n  '       * should be selected. The 'TargetNameAndExtraChars' folder is not an exact match and the file\r\n  '       * 'TargetName' is a file not a folder.\r\n  '       * \r\n  '       * The 'TargetName' folder under 'Folder3_1_1' is an interesting case because it is below a\r\n  '       * previous matched folder. That may or may not be desired. We can address both situations.\r\n  '       \r\n\r\n  Dim baseFolder As AbstractFolder = New DiskFolder(\"NameFilter1\")\r\n\r\n  ' This is the name we will be looking for\r\n  Dim targetName As String = \"TargetName\"\r\n\r\n  ' If our test folders don't exist\r\n  If (Not baseFolder.Exists) Then\r\n    ' We will create a set of files and folders to test our filter \r\n\r\n    Dim sourceFile, file As AbstractFile\r\n    Dim folder As AbstractFolder\r\n\r\n    file = baseFolder.GetFile(\"File6.dat\")\r\n    file.Create()\r\n    file = baseFolder.GetFile(\"File7.dat\")\r\n    file.Create()\r\n\r\n    sourceFile = file\r\n\r\n    folder = baseFolder.GetFolder(String.Format(\"Folder1\\{0}\\{0}AndExtraChars\", targetName))\r\n    sourceFile.CopyTo(folder.GetFile(\"File1.dat\"), True)\r\n    sourceFile.CopyTo(folder.GetFile(\"File2.dat\"), True)\r\n    sourceFile.CopyTo(folder.GetFile(targetName & \".dat\"), True)\r\n    sourceFile.CopyTo(folder.GetFile(targetName), True)\r\n\r\n    folder = baseFolder.GetFolder(targetName)\r\n    folder.Create()\r\n\r\n    folder = baseFolder.GetFolder(String.Format(\"Folder3\\Folder3_1\\{0}\", targetName))\r\n    sourceFile.CopyTo(folder.GetFile(\"File5.dat\"), True)\r\n    folder = folder.GetFolder(String.Format(\"Folder3_1_1\\{0}\", targetName))\r\n    sourceFile.CopyTo(folder.GetFile(\"File3.dat\"), True)\r\n    sourceFile.CopyTo(folder.GetFile(\"File4.dat\"), True)\r\n  End If\r\n\r\n  Dim folders() As AbstractFolder\r\n  Dim files() As AbstractFile\r\n\r\n  '      \r\n  '       * The simplest approach is use a NameFilter object and set the scope to FilterScope.Folder.\r\n  '       * This will select all the folders that have our targetName.\r\n  '       * \r\n  '       * The key is the FilterScope argument set to Folder \r\n\r\n  ' Create a name filter that accepts our targetName on a folder only (case insensitive)\r\n  Dim nameFilter As New NameFilter(targetName, FilterScope.Folder)\r\n\r\n  ' Get any folder that match our name filter\r\n  folders = baseFolder.GetFolders(True, nameFilter)\r\n\r\n  Console.WriteLine(\"Simple filtering\")\r\n  For Each folder As AbstractFolder In folders\r\n    Console.WriteLine(folder.FullName)\r\n  Next folder\r\n  Console.WriteLine()\r\n\r\n  '       The output will be:\r\n  '       * NameFilter1->Folder1->TargetName\r\n  '       * NameFilter1->TargetName\r\n  '       * NameFilter1->Folder3->Folder3_1->TargetName\r\n  '       * NameFilter1->Folder3->Folder3_1->TargetName->Folder3_1_1->TargetName\r\n  '\r\n  '\r\n  '      /*\r\n  '       * If you only want the most top level folder that matches the filter and not any sub folders\r\n  '       * that also match the filter, you can add filters that exclude them.\r\n  '       * \r\n  '       * The key is to prevent the filtering engine to recurse into folders that match our tagetName.\r\n  '       * Again, the FilterScope parameter can be put to good use.\r\n  '       \r\n\r\n  ' Create a name filter that matches the name 'Aid' but only when determining if the\r\n  ' filter engine should look into a recursed folder\r\n  Dim recurseFilter As New NameFilter(targetName, FilterScope.Recurse)\r\n\r\n  ' Wrap our recurse filter in a NotFilter to invert the decision\r\n  Dim notFilter As New NotFilter(recurseFilter)\r\n\r\n  ' Get all the folders that match our name and do not match the name when recursing into sub folders\r\n  folders = baseFolder.GetFolders(True, nameFilter, notFilter)\r\n\r\n  Console.WriteLine(\"Filtering with only top-level matches\")\r\n  For Each folder As AbstractFolder In folders\r\n    Console.WriteLine(folder.FullName)\r\n\r\n    '         TODO: Here, you can process all the files that are in the folder individually\r\n    '            with folder.GetFiles() or as a group using methods like folder.CopyFilesTo(), etc \r\n  Next folder\r\n  Console.WriteLine()\r\n\r\n  '****************************\r\n\r\n  ' If you're simply looking for files \r\n\r\n  ' Get all the files that match our name (this works because by default, the FilterScore is for files only)\r\n  files = baseFolder.GetFiles(True, targetName)\r\n\r\n  Console.WriteLine(\"Filtering for files only\")\r\n  For Each file As AbstractFile In files\r\n    Console.WriteLine(file.FullName)\r\n  Next file\r\n  Console.WriteLine()\n"})})})]}),"\n",(0,l.jsx)(r.h2,{id:"things-you-should-consider",children:"Things you should consider"}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["Do you only want to target specific types of folder items? Use the ",(0,l.jsx)(r.code,{children:"FilterScope"})," enumeration in the constructor of the ",(0,l.jsx)(r.code,{children:"NameFilter"})," class."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,l.jsx)(r,{...e,children:(0,l.jsx)(F,{...e})}):F(e)}},19365:(e,r,t)=>{t.d(r,{A:()=>i});t(96540);var l=t(34164);const n={tabItem:"tabItem_Ymn6"};var a=t(74848);function i(e){let{children:r,hidden:t,className:i}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,l.A)(n.tabItem,i),hidden:t,children:r})}},11470:(e,r,t)=>{t.d(r,{A:()=>y});var l=t(96540),n=t(34164),a=t(23104),i=t(56347),s=t(205),o=t(57485),d=t(31682),c=t(70679);function u(e){return l.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,l.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function F(e){const{values:r,children:t}=e;return(0,l.useMemo)((()=>{const e=r??function(e){return u(e).map((e=>{let{props:{value:r,label:t,attributes:l,default:n}}=e;return{value:r,label:t,attributes:l,default:n}}))}(t);return function(e){const r=(0,d.XI)(e,((e,r)=>e.value===r.value));if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[r,t])}function h(e){let{value:r,tabValues:t}=e;return t.some((e=>e.value===r))}function m(e){let{queryString:r=!1,groupId:t}=e;const n=(0,i.W6)(),a=function(e){let{queryString:r=!1,groupId:t}=e;if("string"==typeof r)return r;if(!1===r)return null;if(!0===r&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:r,groupId:t});return[(0,o.aZ)(a),(0,l.useCallback)((e=>{if(!a)return;const r=new URLSearchParams(n.location.search);r.set(a,e),n.replace({...n.location,search:r.toString()})}),[a,n])]}function f(e){const{defaultValue:r,queryString:t=!1,groupId:n}=e,a=F(e),[i,o]=(0,l.useState)((()=>function(e){let{defaultValue:r,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!h({value:r,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${r}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return r}const l=t.find((e=>e.default))??t[0];if(!l)throw new Error("Unexpected error: 0 tabValues");return l.value}({defaultValue:r,tabValues:a}))),[d,u]=m({queryString:t,groupId:n}),[f,p]=function(e){let{groupId:r}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(r),[n,a]=(0,c.Dv)(t);return[n,(0,l.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:n}),b=(()=>{const e=d??f;return h({value:e,tabValues:a})?e:null})();(0,s.A)((()=>{b&&o(b)}),[b]);return{selectedValue:i,selectValue:(0,l.useCallback)((e=>{if(!h({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),p(e)}),[u,p,a]),tabValues:a}}var p=t(92303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=t(74848);function N(e){let{className:r,block:t,selectedValue:l,selectValue:i,tabValues:s}=e;const o=[],{blockElementScrollPositionUntilNextRender:d}=(0,a.a_)(),c=e=>{const r=e.currentTarget,t=o.indexOf(r),n=s[t].value;n!==l&&(d(r),i(n))},u=e=>{let r=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;r=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;r=o[t]??o[o.length-1];break}}r?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,n.A)("tabs",{"tabs--block":t},r),children:s.map((e=>{let{value:r,label:t,attributes:a}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:l===r?0:-1,"aria-selected":l===r,ref:e=>o.push(e),onKeyDown:u,onClick:c,...a,className:(0,n.A)("tabs__item",b.tabItem,a?.className,{"tabs__item--active":l===r}),children:t??r},r)}))})}function x(e){let{lazy:r,children:t,selectedValue:a}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(r){const e=i.find((e=>e.props.value===a));return e?(0,l.cloneElement)(e,{className:(0,n.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:i.map(((e,r)=>(0,l.cloneElement)(e,{key:r,hidden:e.props.value!==a})))})}function T(e){const r=f(e);return(0,g.jsxs)("div",{className:(0,n.A)("tabs-container",b.tabList),children:[(0,g.jsx)(N,{...r,...e}),(0,g.jsx)(x,{...r,...e})]})}function y(e){const r=(0,p.A)();return(0,g.jsx)(T,{...e,children:u(e.children)},String(r))}},28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>s});var l=t(96540);const n={},a=l.createContext(n);function i(e){const r=l.useContext(a);return l.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),l.createElement(a.Provider,{value:r},e.children)}}}]);