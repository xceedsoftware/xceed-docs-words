"use strict";(self.webpackChunkxceed_libs_doc=self.webpackChunkxceed_libs_doc||[]).push([[4528],{90845:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>u});var a=r(74848),n=r(28453),i=r(11470),s=r(19365);const o={},l="Reading and writing nested Zip archives",d={id:"code-snippets/unzipping/reading-writing-nested-zip",title:"Reading and writing nested Zip archives",description:"The following examples show how to use the ZipReader.GetItemDataStream and ZipWriter.GetItemDataStream methods to allow the component to easily handle nested zip archives.",source:"@site/zip/code-snippets/unzipping/reading-writing-nested-zip.md",sourceDirName:"code-snippets/unzipping",slug:"/code-snippets/unzipping/reading-writing-nested-zip",permalink:"/xceed-libs-doc/zip/code-snippets/unzipping/reading-writing-nested-zip",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebarzip",previous:{title:"Extracting data from a Zip archive using ZipReader",permalink:"/xceed-libs-doc/zip/code-snippets/unzipping/extracting-data-from-zip-zipreader"},next:{title:"Unzipping items from zip file in an application's resources",permalink:"/xceed-libs-doc/zip/code-snippets/unzipping/unzipping-items-from-zip-app-res"}},c={},u=[];function m(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"reading-and-writing-nested-zip-archives",children:"Reading and writing nested Zip archives"})}),"\n",(0,a.jsx)(t.p,{children:"The following examples show how to use the ZipReader.GetItemDataStream and ZipWriter.GetItemDataStream methods to allow the component to easily handle nested zip archives."}),"\n",(0,a.jsx)(t.p,{children:"A nested zip archive is when an item in an archive is another zip archive. By providing the stream returned by the method to a new instance of ZipWriter or ZipReader, a nested zip file will be created or read."}),"\n",(0,a.jsx)(t.p,{children:"The first example shows how the ZipWriter.GetItemDataStream() method can be used to create a nested Zip archive."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(s.A,{value:"csharp",label:"C#",default:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'  private void NestedArchiveExample( Stream someStream )\r\n  {\r\n    using( ZipWriter writer = new ZipWriter( someStream ) )\r\n    {\r\n      ZipItemLocalHeader header = new ZipItemLocalHeader();\r\n\r\n      header.FileName = "File1.zip";\r\n      writer.WriteItemLocalHeader( header );\r\n\r\n      // Create a write stream that wraps the item\'s data\r\n      using( Stream itemStream = writer.GetItemDataStream() )\r\n      {\r\n        // Feed the item stream to a new instance of ZipWriter\r\n        using( ZipWriter nestedWriter = new ZipWriter( itemStream ) )\r\n        {\r\n          /* The \'using\' statement will insure the nested zip file is properly terminated */\r\n\r\n          // Add an item and some data into the nested zip file\r\n          header.FileName = "File1.dat";\r\n          nestedWriter.WriteItemLocalHeader( header );\r\n          nestedWriter.WriteItemData( MediumFile1 );\r\n        }\r\n      }\r\n    }\r\n  }\n'})})}),(0,a.jsx)(s.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-vb.NET",children:"Private Sub NestedArchiveExample(ByVal someStream As Stream)\r\n  Using writer As New ZipWriter(someStream)\r\n    Dim header As New ZipItemLocalHeader()\r\n\r\n    header.FileName = \"File1.zip\"\r\n    writer.WriteItemLocalHeader(header)\r\n\r\n    ' Create a write stream that wraps the item's data\r\n    Using itemStream As Stream = writer.GetItemDataStream()\r\n      ' Feed the item stream to a new instance of ZipWriter\r\n      Using nestedWriter As New ZipWriter(itemStream)\r\n        ' The 'using' statement will insure the nested zip file is properly terminated\r\n\r\n        ' Add an item and some data into the nested zip file\r\n        header.FileName = \"File1.dat\"\r\n        nestedWriter.WriteItemLocalHeader(header)\r\n        nestedWriter.WriteItemData(MediumFile1)\r\n      End Using\r\n    End Using\r\n  End Using\r\nEnd Sub\n"})})})]}),"\n",(0,a.jsx)(t.p,{children:"The second example shows how the ZipReader.GetItemDataStream method can be used to read a nested Zip archive."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(s.A,{value:"csharp",label:"C#",default:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"  private void ReadZipArchive( Stream archiveStream )\r\n  {\r\n    using( ZipReader reader = new ZipReader( archiveStream ) )\r\n    {\r\n      ZipItemLocalHeader header;\r\n\r\n      while( ( header = reader.ReadItemLocalHeader() ) != null )\r\n      {\r\n        /* The component will not automatically identity what is and is\r\n        * not a nested zip file. The application needs to have its own mechanism.\r\n        *\r\n        * This example will keep it simple and just look at the item's file name extension. */\r\n\r\n        // If the item's extension is .zip\r\n        if( StringComparer.OrdinalIgnoreCase.Compare( Path.GetExtension( header.FileName ), \".zip\" ) == 0 )\r\n        {\r\n          // Create a read stream that wraps the item's data\r\n          using( Stream itemStream = reader.GetItemDataStream() )\r\n          {\r\n            /* NOTE: While using a recursive call here makes for elegant and compact code that\r\n            * helps illustrate the concept of nested zip archives, a maliciously crafted zip file\r\n            * made up of a large number of nested zip files could make this code cause a stack overflow\r\n            * due to excessive recursion. */\r\n\r\n            // Call ourselves to read the nested archive\r\n            this.ReadZipArchive( itemStream );\r\n          }\r\n\r\n          /* IMPORTANT: Before we can move on to the next item in the archive, ZipReader must have\r\n          * reached the end of the current item's data. Reading a nested zip file does not ensure\r\n          * this, so we need to make sure here by reading any remaining data into a dummy stream.\r\n          *\r\n          * Failure to do this will result in a ZipReaderException that reports that the object\r\n          * is not in the correct state to read the next item header. */\r\n\r\n          // Make sure we reach the end of the item's data\r\n          reader.ReadItemData( Stream.Null );\r\n        }\r\n        else\r\n        {\r\n          // This example does not concern itself with normal items\r\n          reader.ReadItemData( Stream.Null );\r\n        }\r\n      }\r\n    }\r\n  }\n"})})}),(0,a.jsx)(s.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-vb.NET",children:"Private Sub ReadZipArchive(ByVal archiveStream As Stream)\r\n  Using reader As New ZipReader(archiveStream)\r\n    Dim header As ZipItemLocalHeader\r\n\r\n    header = reader.ReadItemLocalHeader()\r\n    Do While header IsNot Nothing\r\n'      The component will not automatically identity what is and is\r\n'      not a nested zip file. The application needs to have its own mechanism.\r\n'     \r\n'      This example will keep it simple and just look at the item's file name extension.\r\n\r\n      ' If the item's extension is .zip\r\n      If StringComparer.OrdinalIgnoreCase.Compare(Path.GetExtension(header.FileName), \".zip\") = 0 Then\r\n        ' Create a read stream that wraps the item's data\r\n        Using itemStream As Stream = reader.GetItemDataStream()\r\n'          NOTE: While using a recursive call here makes for elegant and compact code that\r\n'          helps illustrate the concept of nested zip archives, a maliciously crafted zip file\r\n'          made up of a large number of nested zip files could make this code cause a stack overflow\r\n'          due to excessive recursion.\r\n\r\n          ' Call ourselves to read the nested archive\r\n          Me.ReadZipArchive(itemStream)\r\n        End Using\r\n\r\n'        IMPORTANT: Before we can move on to the next item in the archive, ZipReader must have\r\n'        reached the end of the current item's data. Reading a nested zip file does not ensure\r\n'        this, so we need to make sure here by reading any remaining data into a dummy stream.\r\n'       \r\n'        Failure to do this will result in a ZipReaderException that reports that the object\r\n'        is not in the correct state to read the next item header.\r\n\r\n        ' Make sure we reach the end of the item's data\r\n        reader.ReadItemData(Stream.Null)\r\n      Else\r\n        ' This example does not concern itself with normal items\r\n        reader.ReadItemData(Stream.Null)\r\n      End If\r\n      header = reader.ReadItemLocalHeader()\r\n    Loop\r\n  End Using\r\nEnd Sub\n"})})})]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},19365:(e,t,r)=>{r.d(t,{A:()=>s});r(96540);var a=r(34164);const n={tabItem:"tabItem_Ymn6"};var i=r(74848);function s(e){let{children:t,hidden:r,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(n.tabItem,s),hidden:r,children:t})}},11470:(e,t,r)=>{r.d(t,{A:()=>S});var a=r(96540),n=r(34164),i=r(23104),s=r(56347),o=r(205),l=r(57485),d=r(31682),c=r(70679);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:t,children:r}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:r,attributes:a,default:n}}=e;return{value:t,label:r,attributes:a,default:n}}))}(r);return function(e){const t=(0,d.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function h(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:r}=e;const n=(0,s.W6)(),i=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(n.location.search);t.set(i,e),n.replace({...n.location,search:t.toString()})}),[i,n])]}function f(e){const{defaultValue:t,queryString:r=!1,groupId:n}=e,i=m(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=r.find((e=>e.default))??r[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[d,u]=p({queryString:r,groupId:n}),[f,g]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,i]=(0,c.Dv)(r);return[n,(0,a.useCallback)((e=>{r&&i.set(e)}),[r,i])]}({groupId:n}),v=(()=>{const e=d??f;return h({value:e,tabValues:i})?e:null})();(0,o.A)((()=>{v&&l(v)}),[v]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),g(e)}),[u,g,i]),tabValues:i}}var g=r(92303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=r(74848);function w(e){let{className:t,block:r,selectedValue:a,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.a_)(),c=e=>{const t=e.currentTarget,r=l.indexOf(t),n=o[r].value;n!==a&&(d(t),s(n))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const r=l.indexOf(e.currentTarget)+1;t=l[r]??l[0];break}case"ArrowLeft":{const r=l.indexOf(e.currentTarget)-1;t=l[r]??l[l.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,n.A)("tabs",{"tabs--block":r},t),children:o.map((e=>{let{value:t,label:r,attributes:i}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>l.push(e),onKeyDown:u,onClick:c,...i,className:(0,n.A)("tabs__item",v.tabItem,i?.className,{"tabs__item--active":a===t}),children:r??t},t)}))})}function x(e){let{lazy:t,children:r,selectedValue:i}=e;const s=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:(0,n.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:s.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==i})))})}function I(e){const t=f(e);return(0,b.jsxs)("div",{className:(0,n.A)("tabs-container",v.tabList),children:[(0,b.jsx)(w,{...t,...e}),(0,b.jsx)(x,{...t,...e})]})}function S(e){const t=(0,g.A)();return(0,b.jsx)(I,{...e,children:u(e.children)},String(t))}},28453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>o});var a=r(96540);const n={},i=a.createContext(n);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);