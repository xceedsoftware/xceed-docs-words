"use strict";(self.webpackChunkxceed_libs_doc=self.webpackChunkxceed_libs_doc||[]).push([[7761],{3330:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var r=n(74848),i=n(28453),a=n(11470),o=n(19365);const s={},l="Key exchange and algorithm negotiation",c={id:"basic-concepts/sftp-capabilities/key-exch-algorithm-negotiation",title:"Key exchange and algorithm negotiation",description:"Key exchange description",source:"@site/ftp/basic-concepts/sftp-capabilities/key-exch-algorithm-negotiation.md",sourceDirName:"basic-concepts/sftp-capabilities",slug:"/basic-concepts/sftp-capabilities/key-exch-algorithm-negotiation",permalink:"/xceed-libs-doc/ftp/basic-concepts/sftp-capabilities/key-exch-algorithm-negotiation",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebarftp",previous:{title:"Keyboard Interactive Authentication",permalink:"/xceed-libs-doc/ftp/basic-concepts/sftp-capabilities/keyboard-interactive-auth"},next:{title:"Handling File Sharing Issues",permalink:"/xceed-libs-doc/ftp/basic-concepts/sftp-capabilities/handling-file-sharing-issues"}},h={},d=[{value:"Key exchange description",id:"key-exchange-description",level:2},{value:"Algorithm negotiation",id:"algorithm-negotiation",level:2},{value:"Algorithm negotiation properties and methods",id:"algorithm-negotiation-properties-and-methods",level:2},{value:"AlgorithmsNegotiated event",id:"algorithmsnegotiated-event",level:2}];function u(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"key-exchange-and-algorithm-negotiation",children:"Key exchange and algorithm negotiation"})}),"\n",(0,r.jsx)(t.h2,{id:"key-exchange-description",children:"Key exchange description"}),"\n",(0,r.jsx)(t.p,{children:"A SSH connection implies the use of several algorithms that, together, make the connection secure. There are several encryption, data integrity, key exchange, public key and compression algorithms to choose from. These choices are made between the client (Xceed SFtp for .NET) and the server during a phase called key exchange. Key exchange occurs immediately after a connection with the server is made. It also occurs during a session at regular intervals determined by the server."}),"\n",(0,r.jsx)(t.p,{children:"An encryption algorithm and a key is negotiated during the key exchange. When encryption is in effect, all data, including meta-data like packet lengths and padding fields will be encrypted with the given algorithm."}),"\n",(0,r.jsx)(t.p,{children:"Data integrity is protected by including with each packet a message authentication code (MAC) that is computed from a shared secret, packet sequence number, and the contents of the packet."}),"\n",(0,r.jsx)(t.p,{children:"The key exchange method specifies how one-time session keys are generated for encryption and for authentication, and how the server authentication is done."}),"\n",(0,r.jsx)(t.p,{children:"A public key algorithm is used to provide a way to format, sign/encrypt, and encode the keys and certificates exchanged between the client and the server."}),"\n",(0,r.jsx)(t.p,{children:"Packet data can optionally be compressed by the SSH protocol. Please note that at this time, compression is not supported by the component."}),"\n",(0,r.jsxs)(t.p,{children:["A list of all the algorithms supported by the component can be found in the technical overview section of the ",(0,r.jsx)(t.a,{href:"/ftp/basic-concepts/ftp-capabilities/overview",children:"SFtp Capabilities"})," page."]}),"\n",(0,r.jsx)(t.p,{children:"Key exchange is performed automatically and generally does not require input from the application with one exception that will be covered below."}),"\n",(0,r.jsx)(t.h2,{id:"algorithm-negotiation",children:"Algorithm negotiation"}),"\n",(0,r.jsx)(t.p,{children:"With so many algorithms to chose from, the client and server decide together on which to use using a simple ordered list system. For each algorithm category, the client and server exchange a list of algorithms they support and want to use in order of preference. The chosen algorithm will be the first one that appear in both lists."}),"\n",(0,r.jsx)(t.p,{children:"As an example, consider the following encryption algorithm lists. The client's list:"}),"\n",(0,r.jsx)(t.p,{children:"aes128-cbc, aes256-cbc, aes128-ctr, 3des-cbc, arcfour256, none\r\nThe server's list:"}),"\n",(0,r.jsx)(t.p,{children:"aes128-ctr, aes256-ctr, aes192-ctr\r\nThe first common algorithm is aes128-ctr and so that is the one that will be used for encryption. If no common algorithms are found, negotiation fails and both parties will disconnect."}),"\n",(0,r.jsx)(t.h2,{id:"algorithm-negotiation-properties-and-methods",children:"Algorithm negotiation properties and methods"}),"\n",(0,r.jsxs)(t.p,{children:["The technical overview section of the ",(0,r.jsx)(t.a,{href:"/ftp/basic-concepts/ftp-capabilities/overview",children:"SFtp Capabilities"})," page lists the algorithms the component supports and the order of preference in which they will be listed."]}),"\n",(0,r.jsx)(t.p,{children:"It is possible to alter the order of the algorithms that the client will expose or to remove algorithms altogether The SSHClient class contains properties that return SSHAlgorithmList objects. They encapsulate the lists and allow them to be manipulated."}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Algorithm list manipulation example"}),(0,r.jsxs)(a.A,{children:[(0,r.jsx)(o.A,{value:"csharp",label:"C#",default:!0,children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'  using Xceed.SSH.Client;\r\n  using Xceed.SSH.Core;\r\n\r\n  namespace DocumentationExamples.SSH\r\n  {\r\n    public static class SSHAlgorithmList1\r\n    {\r\n      public static void Example()\r\n      {\r\n        string host = "yourhost.org";\r\n        string username = "your username";\r\n        string password = "your password";\r\n\r\n        SSHClient ssh = new SSHClient();\r\n\r\n        // Get the encryption algorithm list that affect both client-to-server and server-to-client\r\n        SSHAlgorithmList encryptionAlgorithms = ssh.EncryptionAlgorithmList;\r\n\r\n        // Re-order the different AES Ctr algorithms to the front of the list\r\n        encryptionAlgorithms.MoveToFirst( SSHEncryptionMethods.AES128CtrEncryption );\r\n        encryptionAlgorithms.MoveToFirst( SSHEncryptionMethods.AES192CtrEncryption );\r\n        encryptionAlgorithms.MoveToFirst( SSHEncryptionMethods.AES256CtrEncryption );\r\n\r\n        // Remove the AES128CtrEncryption from the list\r\n        encryptionAlgorithms.Remove( SSHEncryptionMethods.AES128CtrEncryption );\r\n\r\n        // Display the list of algorithms\r\n        Console.WriteLine( encryptionAlgorithms );\r\n\r\n\r\n        // Get the key exchange algorithm list\r\n        SSHAlgorithmList keyExchangeAlgorithms = ssh.KeyExchangeAlgorithmList;\r\n\r\n        /* DiffieHellmanGroupExchangeSHA256 is already part of the list. But that\'s ok. The AddFirst()\r\n          method gracefully handles duplicates and will move the string to its new location in the list. */\r\n\r\n        // Move DiffieHellmanGroupExchangeSHA256 to the head of the list\r\n        keyExchangeAlgorithms.AddFirst( SSHKeyExchangeMethods.DiffieHellmanGroupExchangeSHA256 );\r\n\r\n        // Display the list of algorithms\r\n        Console.WriteLine( keyExchangeAlgorithms );\r\n\r\n\r\n        SSHAlgorithmList dataIntegrityAlgorithms = ssh.DataIntegrityAlgorithmList;\r\n        dataIntegrityAlgorithms.Remove( SSHDataIntegrityMethods.NoDataIntegrity );\r\n\r\n\r\n        SSHAlgorithmList publicKeyAlgorithms = ssh.PublicKeyAlgorithmList;\r\n        publicKeyAlgorithms.Remove( SSHPublicKeyMethods.SshDssPublicKeyAlgorithm );\r\n\r\n        /* When the algorithm lists have been arranged to the application\'s satisfaction,\r\n          the connection can be made. If the lists are modified after connection, it will \r\n          take effect in the next key-exchange or the next connection. */\r\n\r\n        ssh.Connect( host );\r\n        ssh.Authenticate( username, password );\r\n\r\n        /* ... */\r\n\r\n        ssh.Disconnect();\r\n      }\r\n    }\r\n  }\n'})})}),(0,r.jsx)(o.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-vb.NET",children:"  Imports Xceed.SSH.Client\r\n  Imports Xceed.SSH.Core\r\n\r\n  Namespace DocumentationExamples.SSH\r\n    Public NotInheritable Class SSHAlgorithmList1\r\n      Private Sub New()\r\n      End Sub\r\n      Public Shared Sub Example()\r\n        Dim host As String = \"yourhost.org\"\r\n        Dim username As String = \"your username\"\r\n        Dim password As String = \"your password\"\r\n\r\n        Dim ssh As New SSHClient()\r\n\r\n        ' Get the encryption algorithm list that affect both client-to-server and server-to-client\r\n        Dim encryptionAlgorithms As SSHAlgorithmList = ssh.EncryptionAlgorithmList\r\n\r\n        ' Re-order the different AES Ctr algorithms to the front of the list\r\n        encryptionAlgorithms.MoveToFirst(SSHEncryptionMethods.AES128CtrEncryption)\r\n        encryptionAlgorithms.MoveToFirst(SSHEncryptionMethods.AES192CtrEncryption)\r\n        encryptionAlgorithms.MoveToFirst(SSHEncryptionMethods.AES256CtrEncryption)\r\n\r\n        ' Remove the AES128CtrEncryption from the list\r\n        encryptionAlgorithms.Remove(SSHEncryptionMethods.AES128CtrEncryption)\r\n\r\n        ' Display the list of algorithms\r\n        Console.WriteLine(encryptionAlgorithms)\r\n\r\n\r\n        ' Get the key exchange algorithm list\r\n        Dim keyExchangeAlgorithms As SSHAlgorithmList = ssh.KeyExchangeAlgorithmList\r\n\r\n  '       DiffieHellmanGroupExchangeSHA256 is already part of the list. But that's ok. The AddFirst()\r\n  '         method gracefully handles duplicates and will move the string to its new location in the list. \r\n\r\n        ' Move DiffieHellmanGroupExchangeSHA256 to the head of the list\r\n        keyExchangeAlgorithms.AddFirst(SSHKeyExchangeMethods.DiffieHellmanGroupExchangeSHA256)\r\n\r\n        ' Display the list of algorithms\r\n        Console.WriteLine(keyExchangeAlgorithms)\r\n\r\n\r\n        Dim dataIntegrityAlgorithms As SSHAlgorithmList = ssh.DataIntegrityAlgorithmList\r\n        dataIntegrityAlgorithms.Remove(SSHDataIntegrityMethods.NoDataIntegrity)\r\n\r\n\r\n        Dim publicKeyAlgorithms As SSHAlgorithmList = ssh.PublicKeyAlgorithmList\r\n        publicKeyAlgorithms.Remove(SSHPublicKeyMethods.SshDssPublicKeyAlgorithm)\r\n\r\n  '       When the algorithm lists have been arranged to the application's satisfaction,\r\n  '         the connection can be made. If the lists are modified after connection, it will \r\n  '         take effect in the next key-exchange or the next connection. \r\n\r\n        ssh.Connect(host)\r\n        ssh.Authenticate(username, password)\r\n\r\n        '... \r\n\r\n        ssh.Disconnect()\r\n      End Sub\r\n    End Class\r\n  End Namespace\n"})})})]})]}),"\n",(0,r.jsx)(t.h2,{id:"algorithmsnegotiated-event",children:"AlgorithmsNegotiated event"}),"\n",(0,r.jsx)(t.p,{children:"The SSHClient class has a AlgorithmsNegotiated event. It is triggered after the algorithms lists have been exchanged between the server and the client and the objects that represent the negotiated algorithms have been constructed. It is an ideal place to set options for those algorithms that have them as the example below will demonstrate."}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsx)(t.p,{children:"Is most situations, it is not necessary to handle the AlgorithmsNegotiated event as the default behavior is adequate. Applications should only use the event in advanced scenarios or when a specific options needs to be set for an algorithm object."})}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Algorithms negotiated event example"}),(0,r.jsxs)(a.A,{children:[(0,r.jsx)(o.A,{value:"csharp",label:"C#",default:!0,children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'  using Xceed.SSH.Client;\r\n  using Xceed.SSH.Protocols;\r\n\r\n  namespace DocumentationExamples.SSH\r\n  {\r\n    public static class DiffieHellmanGroupKeyExchange1\r\n    {\r\n      public static void Example()\r\n      {\r\n        string host = "yourhost.org";\r\n        string username = "your username";\r\n        string password = "your password";\r\n\r\n        SSHClient ssh = new SSHClient();\r\n\r\n        /* Subscribe to the AlgorithmsNegotiated so that we can set custom options on the chosen\r\n          algorithms during key exchange */\r\n        ssh.AlgorithmsNegotiated += OnAlgorithmsNegotiated;\r\n\r\n        ssh.Connect( host );\r\n        ssh.Authenticate( username, password );\r\n\r\n        ssh.Disconnect();\r\n        ssh.Dispose();\r\n      }\r\n\r\n      private static void OnAlgorithmsNegotiated( object sender, AlgorithmsNegotiatedEventArgs e )\r\n      {\r\n        // Express the key exchange algorithm interface as a Diffie-Hellman Group Key Exchange object\r\n        DiffieHellmanGroupKeyExchange diffieHellmanGroupKeyExchange = e.KeyExchangeAlgorithm as DiffieHellmanGroupKeyExchange;\r\n\r\n        /* By expressing the key exchange interface as the DiffieHellmanGroupKeyExchange base class, \r\n          we don\'t have to have code specific to the SHA1 and SHA256 variant of the algorithm.\r\n          Both will be covered. */\r\n\r\n        // If we are using a Diffie-Hellman Group Key Exchange (SHA1 or SHA256) for this key exchange\r\n        if( diffieHellmanGroupKeyExchange != null )\r\n        {\r\n          // Force the usage of a custom preferred group size\r\n          diffieHellmanGroupKeyExchange.PreferredGroupSize = 3072;\r\n        }\r\n      }\r\n    }\r\n  }\n'})})}),(0,r.jsx)(o.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-vb.NET",children:"  Imports Xceed.SSH.Client\r\n  Imports Xceed.SSH.Protocols\r\n\r\n  Namespace DocumentationExamples.SSH\r\n    Public NotInheritable Class DiffieHellmanGroupKeyExchange1\r\n      Private Sub New()\r\n      End Sub\r\n      Public Shared Sub Example()\r\n        Dim host As String = \"yourhost.org\"\r\n        Dim username As String = \"your username\"\r\n        Dim password As String = \"your password\"\r\n\r\n        Dim ssh As New SSHClient()\r\n\r\n  '       Subscribe to the AlgorithmsNegotiated so that we can set custom options on the chosen\r\n  '         algorithms during key exchange \r\n        AddHandler ssh.AlgorithmsNegotiated, AddressOf OnAlgorithmsNegotiated\r\n\r\n        ssh.Connect(host)\r\n        ssh.Authenticate(username, password)\r\n\r\n        ssh.Disconnect()\r\n        ssh.Dispose()\r\n      End Sub\r\n\r\n      Private Shared Sub OnAlgorithmsNegotiated(ByVal sender As Object, ByVal e As AlgorithmsNegotiatedEventArgs)\r\n        ' Express the key exchange algorithm interface as a Diffie-Hellman Group Key Exchange object\r\n        Dim diffieHellmanGroupKeyExchange As DiffieHellmanGroupKeyExchange = TryCast(e.KeyExchangeAlgorithm, DiffieHellmanGroupKeyExchange)\r\n\r\n  '       By expressing the key exchange interface as the DiffieHellmanGroupKeyExchange base class,\r\n  '         we don't have to have code specific to the SHA1 and SHA256 variant of the algorithm.\r\n  '         Both will be covered. \r\n\r\n        ' If we are using a Diffie-Hellman Group Key Exchange (SHA1 or SHA256) for this key exchange\r\n        If diffieHellmanGroupKeyExchange IsNot Nothing Then\r\n          ' Force the usage of a custom preferred group size\r\n          diffieHellmanGroupKeyExchange.PreferredGroupSize = 3072\r\n        End If\r\n      End Sub\r\n    End Class\r\n  End Namespace\n"})})})]})]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},19365:(e,t,n)=>{n.d(t,{A:()=>o});n(96540);var r=n(34164);const i={tabItem:"tabItem_Ymn6"};var a=n(74848);function o(e){let{children:t,hidden:n,className:o}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,o),hidden:n,children:t})}},11470:(e,t,n)=>{n.d(t,{A:()=>v});var r=n(96540),i=n(34164),a=n(23104),o=n(56347),s=n(205),l=n(57485),c=n(31682),h=n(70679);function d(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:i}}=e;return{value:t,label:n,attributes:r,default:i}}))}(n);return function(e){const t=(0,c.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function g(e){let{queryString:t=!1,groupId:n}=e;const i=(0,o.W6)(),a=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(a),(0,r.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(i.location.search);t.set(a,e),i.replace({...i.location,search:t.toString()})}),[a,i])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:i}=e,a=u(e),[o,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:a}))),[c,d]=g({queryString:n,groupId:i}),[m,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,a]=(0,h.Dv)(n);return[i,(0,r.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:i}),y=(()=>{const e=c??m;return p({value:e,tabValues:a})?e:null})();(0,s.A)((()=>{y&&l(y)}),[y]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),f(e)}),[d,f,a]),tabValues:a}}var f=n(92303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=n(74848);function x(e){let{className:t,block:n,selectedValue:r,selectValue:o,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),h=e=>{const t=e.currentTarget,n=l.indexOf(t),i=s[n].value;i!==r&&(c(t),o(i))},d=e=>{let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},t),children:s.map((e=>{let{value:t,label:n,attributes:a}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>l.push(e),onKeyDown:d,onClick:h,...a,className:(0,i.A)("tabs__item",y.tabItem,a?.className,{"tabs__item--active":r===t}),children:n??t},t)}))})}function S(e){let{lazy:t,children:n,selectedValue:a}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function A(e){const t=m(e);return(0,b.jsxs)("div",{className:(0,i.A)("tabs-container",y.tabList),children:[(0,b.jsx)(x,{...t,...e}),(0,b.jsx)(S,{...t,...e})]})}function v(e){const t=(0,f.A)();return(0,b.jsx)(A,{...e,children:d(e.children)},String(t))}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var r=n(96540);const i={},a=r.createContext(i);function o(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);