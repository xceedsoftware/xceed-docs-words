"use strict";(self.webpackChunkxceed_docs_words=self.webpackChunkxceed_docs_words||[]).push([[4528],{845:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>u});var a=t(4848),n=t(8453),i=t(1470),s=t(9365);const o={},l="Reading and writing nested Zip archives",d={id:"code-snippets/unzipping/reading-writing-nested-zip",title:"Reading and writing nested Zip archives",description:"The following examples show how to use the ZipReader.GetItemDataStream and ZipWriter.GetItemDataStream methods to allow the component to easily handle nested zip archives.",source:"@site/zip/code-snippets/unzipping/reading-writing-nested-zip.md",sourceDirName:"code-snippets/unzipping",slug:"/code-snippets/unzipping/reading-writing-nested-zip",permalink:"/xceed-docs-words/zip/code-snippets/unzipping/reading-writing-nested-zip",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebarzip",previous:{title:"Extracting data from a Zip archive using ZipReader",permalink:"/xceed-docs-words/zip/code-snippets/unzipping/extracting-data-from-zip-zipreader"},next:{title:"Unzipping items from zip file in an application's resources",permalink:"/xceed-docs-words/zip/code-snippets/unzipping/unzipping-items-from-zip-app-res"}},c={},u=[];function m(e){const r={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"reading-and-writing-nested-zip-archives",children:"Reading and writing nested Zip archives"})}),"\n",(0,a.jsx)(r.p,{children:"The following examples show how to use the ZipReader.GetItemDataStream and ZipWriter.GetItemDataStream methods to allow the component to easily handle nested zip archives."}),"\n",(0,a.jsx)(r.p,{children:"A nested zip archive is when an item in an archive is another zip archive. By providing the stream returned by the method to a new instance of ZipWriter or ZipReader, a nested zip file will be created or read."}),"\n",(0,a.jsx)(r.p,{children:"The first example shows how the ZipWriter.GetItemDataStream() method can be used to create a nested Zip archive."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(s.A,{value:"csharp",label:"C#",default:!0,children:(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-csharp",children:'  private void NestedArchiveExample( Stream someStream )\r\n  {\r\n    using( ZipWriter writer = new ZipWriter( someStream ) )\r\n    {\r\n      ZipItemLocalHeader header = new ZipItemLocalHeader();\r\n\r\n      header.FileName = "File1.zip";\r\n      writer.WriteItemLocalHeader( header );\r\n\r\n      // Create a write stream that wraps the item\'s data\r\n      using( Stream itemStream = writer.GetItemDataStream() )\r\n      {\r\n        // Feed the item stream to a new instance of ZipWriter\r\n        using( ZipWriter nestedWriter = new ZipWriter( itemStream ) )\r\n        {\r\n          /* The \'using\' statement will insure the nested zip file is properly terminated */\r\n\r\n          // Add an item and some data into the nested zip file\r\n          header.FileName = "File1.dat";\r\n          nestedWriter.WriteItemLocalHeader( header );\r\n          nestedWriter.WriteItemData( MediumFile1 );\r\n        }\r\n      }\r\n    }\r\n  }\n'})})}),(0,a.jsx)(s.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-vb.NET",children:"Private Sub NestedArchiveExample(ByVal someStream As Stream)\r\n  Using writer As New ZipWriter(someStream)\r\n    Dim header As New ZipItemLocalHeader()\r\n\r\n    header.FileName = \"File1.zip\"\r\n    writer.WriteItemLocalHeader(header)\r\n\r\n    ' Create a write stream that wraps the item's data\r\n    Using itemStream As Stream = writer.GetItemDataStream()\r\n      ' Feed the item stream to a new instance of ZipWriter\r\n      Using nestedWriter As New ZipWriter(itemStream)\r\n        ' The 'using' statement will insure the nested zip file is properly terminated\r\n\r\n        ' Add an item and some data into the nested zip file\r\n        header.FileName = \"File1.dat\"\r\n        nestedWriter.WriteItemLocalHeader(header)\r\n        nestedWriter.WriteItemData(MediumFile1)\r\n      End Using\r\n    End Using\r\n  End Using\r\nEnd Sub\n"})})})]}),"\n",(0,a.jsx)(r.p,{children:"The second example shows how the ZipReader.GetItemDataStream method can be used to read a nested Zip archive."}),"\n",(0,a.jsxs)(i.A,{children:[(0,a.jsx)(s.A,{value:"csharp",label:"C#",default:!0,children:(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-csharp",children:"  private void ReadZipArchive( Stream archiveStream )\r\n  {\r\n    using( ZipReader reader = new ZipReader( archiveStream ) )\r\n    {\r\n      ZipItemLocalHeader header;\r\n\r\n      while( ( header = reader.ReadItemLocalHeader() ) != null )\r\n      {\r\n        /* The component will not automatically identity what is and is\r\n        * not a nested zip file. The application needs to have its own mechanism.\r\n        *\r\n        * This example will keep it simple and just look at the item's file name extension. */\r\n\r\n        // If the item's extension is .zip\r\n        if( StringComparer.OrdinalIgnoreCase.Compare( Path.GetExtension( header.FileName ), \".zip\" ) == 0 )\r\n        {\r\n          // Create a read stream that wraps the item's data\r\n          using( Stream itemStream = reader.GetItemDataStream() )\r\n          {\r\n            /* NOTE: While using a recursive call here makes for elegant and compact code that\r\n            * helps illustrate the concept of nested zip archives, a maliciously crafted zip file\r\n            * made up of a large number of nested zip files could make this code cause a stack overflow\r\n            * due to excessive recursion. */\r\n\r\n            // Call ourselves to read the nested archive\r\n            this.ReadZipArchive( itemStream );\r\n          }\r\n\r\n          /* IMPORTANT: Before we can move on to the next item in the archive, ZipReader must have\r\n          * reached the end of the current item's data. Reading a nested zip file does not ensure\r\n          * this, so we need to make sure here by reading any remaining data into a dummy stream.\r\n          *\r\n          * Failure to do this will result in a ZipReaderException that reports that the object\r\n          * is not in the correct state to read the next item header. */\r\n\r\n          // Make sure we reach the end of the item's data\r\n          reader.ReadItemData( Stream.Null );\r\n        }\r\n        else\r\n        {\r\n          // This example does not concern itself with normal items\r\n          reader.ReadItemData( Stream.Null );\r\n        }\r\n      }\r\n    }\r\n  }\n"})})}),(0,a.jsx)(s.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-vb.NET",children:"Private Sub ReadZipArchive(ByVal archiveStream As Stream)\r\n  Using reader As New ZipReader(archiveStream)\r\n    Dim header As ZipItemLocalHeader\r\n\r\n    header = reader.ReadItemLocalHeader()\r\n    Do While header IsNot Nothing\r\n'      The component will not automatically identity what is and is\r\n'      not a nested zip file. The application needs to have its own mechanism.\r\n'     \r\n'      This example will keep it simple and just look at the item's file name extension.\r\n\r\n      ' If the item's extension is .zip\r\n      If StringComparer.OrdinalIgnoreCase.Compare(Path.GetExtension(header.FileName), \".zip\") = 0 Then\r\n        ' Create a read stream that wraps the item's data\r\n        Using itemStream As Stream = reader.GetItemDataStream()\r\n'          NOTE: While using a recursive call here makes for elegant and compact code that\r\n'          helps illustrate the concept of nested zip archives, a maliciously crafted zip file\r\n'          made up of a large number of nested zip files could make this code cause a stack overflow\r\n'          due to excessive recursion.\r\n\r\n          ' Call ourselves to read the nested archive\r\n          Me.ReadZipArchive(itemStream)\r\n        End Using\r\n\r\n'        IMPORTANT: Before we can move on to the next item in the archive, ZipReader must have\r\n'        reached the end of the current item's data. Reading a nested zip file does not ensure\r\n'        this, so we need to make sure here by reading any remaining data into a dummy stream.\r\n'       \r\n'        Failure to do this will result in a ZipReaderException that reports that the object\r\n'        is not in the correct state to read the next item header.\r\n\r\n        ' Make sure we reach the end of the item's data\r\n        reader.ReadItemData(Stream.Null)\r\n      Else\r\n        ' This example does not concern itself with normal items\r\n        reader.ReadItemData(Stream.Null)\r\n      End If\r\n      header = reader.ReadItemLocalHeader()\r\n    Loop\r\n  End Using\r\nEnd Sub\n"})})})]})]})}function h(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},9365:(e,r,t)=>{t.d(r,{A:()=>s});t(6540);var a=t(4164);const n={tabItem:"tabItem_Ymn6"};var i=t(4848);function s(e){let{children:r,hidden:t,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(n.tabItem,s),hidden:t,children:r})}},1470:(e,r,t)=>{t.d(r,{A:()=>S});var a=t(6540),n=t(4164),i=t(3104),s=t(6347),o=t(205),l=t(7485),d=t(1682),c=t(679);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:r}=e;return!!r&&"object"==typeof r&&"value"in r}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:r,children:t}=e;return(0,a.useMemo)((()=>{const e=r??function(e){return u(e).map((e=>{let{props:{value:r,label:t,attributes:a,default:n}}=e;return{value:r,label:t,attributes:a,default:n}}))}(t);return function(e){const r=(0,d.XI)(e,((e,r)=>e.value===r.value));if(r.length>0)throw new Error(`Docusaurus error: Duplicate values "${r.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[r,t])}function h(e){let{value:r,tabValues:t}=e;return t.some((e=>e.value===r))}function p(e){let{queryString:r=!1,groupId:t}=e;const n=(0,s.W6)(),i=function(e){let{queryString:r=!1,groupId:t}=e;if("string"==typeof r)return r;if(!1===r)return null;if(!0===r&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:r,groupId:t});return[(0,l.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const r=new URLSearchParams(n.location.search);r.set(i,e),n.replace({...n.location,search:r.toString()})}),[i,n])]}function f(e){const{defaultValue:r,queryString:t=!1,groupId:n}=e,i=m(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:r,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(r){if(!h({value:r,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${r}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return r}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:r,tabValues:i}))),[d,u]=p({queryString:t,groupId:n}),[f,g]=function(e){let{groupId:r}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(r),[n,i]=(0,c.Dv)(t);return[n,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:n}),v=(()=>{const e=d??f;return h({value:e,tabValues:i})?e:null})();(0,o.A)((()=>{v&&l(v)}),[v]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),g(e)}),[u,g,i]),tabValues:i}}var g=t(2303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=t(4848);function b(e){let{className:r,block:t,selectedValue:a,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.a_)(),c=e=>{const r=e.currentTarget,t=l.indexOf(r),n=o[t].value;n!==a&&(d(r),s(n))},u=e=>{let r=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;r=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;r=l[t]??l[l.length-1];break}}r?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,n.A)("tabs",{"tabs--block":t},r),children:o.map((e=>{let{value:r,label:t,attributes:i}=e;return(0,w.jsx)("li",{role:"tab",tabIndex:a===r?0:-1,"aria-selected":a===r,ref:e=>l.push(e),onKeyDown:u,onClick:c,...i,className:(0,n.A)("tabs__item",v.tabItem,i?.className,{"tabs__item--active":a===r}),children:t??r},r)}))})}function x(e){let{lazy:r,children:t,selectedValue:i}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(r){const e=s.find((e=>e.props.value===i));return e?(0,a.cloneElement)(e,{className:(0,n.A)("margin-top--md",e.props.className)}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:s.map(((e,r)=>(0,a.cloneElement)(e,{key:r,hidden:e.props.value!==i})))})}function I(e){const r=f(e);return(0,w.jsxs)("div",{className:(0,n.A)("tabs-container",v.tabList),children:[(0,w.jsx)(b,{...r,...e}),(0,w.jsx)(x,{...r,...e})]})}function S(e){const r=(0,g.A)();return(0,w.jsx)(I,{...e,children:u(e.children)},String(r))}},8453:(e,r,t)=>{t.d(r,{R:()=>s,x:()=>o});var a=t(6540);const n={},i=a.createContext(n);function s(e){const r=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(i.Provider,{value:r},e.children)}}}]);