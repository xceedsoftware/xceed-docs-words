"use strict";(self.webpackChunkxceed_libs_doc=self.webpackChunkxceed_libs_doc||[]).push([[6068],{83896:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>m,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var r=t(74848),s=t(28453),a=t(11470),o=t(19365);const i={},m="Remote Command Execution",c={id:"basic-concepts/sftp-capabilities/remote-command-exec",title:"Remote Command Execution",description:"Description",source:"@site/ftp/basic-concepts/sftp-capabilities/remote-command-exec.md",sourceDirName:"basic-concepts/sftp-capabilities",slug:"/basic-concepts/sftp-capabilities/remote-command-exec",permalink:"/xceed-libs-doc/ftp/basic-concepts/sftp-capabilities/remote-command-exec",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebarftp",previous:{title:"Handling File Sharing Issues",permalink:"/xceed-libs-doc/ftp/basic-concepts/sftp-capabilities/handling-file-sharing-issues"},next:{title:"Filters",permalink:"/xceed-libs-doc/ftp/basic-concepts/filters/overview"}},l={},d=[{value:"Description",id:"description",level:2},{value:"Usage",id:"usage",level:2},{value:"Examples",id:"examples",level:2}];function u(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"remote-command-execution",children:"Remote Command Execution"})}),"\n",(0,r.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,r.jsx)(n.p,{children:"The SSH protocol allows for the remote execution of commands on the server. This is done using a SSH logical channel. Many SSH features like SFtp and remote command execution are implemented over such channels. Every channel is multiplexed into a single encrypted SSH connection."}),"\n",(0,r.jsx)(n.p,{children:"As such, a remote command execution can be issued while a SFtp session is performing work since a new channel will be created to issue the command."}),"\n",(0,r.jsx)(n.p,{children:"Remote command execution works by the client sending a message that requests the server start the execution of a given command string. The 'command' string may contain a path and arguments. It is also possible to pass environment variables to the server before the command is executed."}),"\n",(0,r.jsx)(n.p,{children:"It should be noted that servers will take normal precautions to prevent the execution of unauthorized commands. At the very least, this means that the right to execute a command, and which commands are allowed will depend on the user that is authenticated on the SSH connection. These rights are determined by the server's administrator and cannot be computed on the client side."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"If a user doesn't have the rights to execute a command, an exception will be thrown but the SSH connection will not be closed. Other channels (like SFtp sessions) will continue to proceed without issue."})}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:["A remote command is executed using the ",(0,r.jsx)(n.code,{children:"Xceed.SSH.Client.ExecuteCommandSession"})," Class. Its constructor needs to be supplied a SSHClient object that is connected and authenticated. Then, the Connect() method can be called, specifying the command to execute and, optionally, environment variables to set on the server before the command is executed."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ExecuteCommandSession"})," class is ony available with the Xceed SFtp for .NET that is compiled for .NET 4.0 and later. The class is available with Xceed SFtp for Xamarin, all versions."]})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Connect()"})," method returns immediately if the server accepts the command. If not, a SSHChannelRequestFailedException is thrown. The command is run on the server while control continues normall on the client side. The server might send standard output and/or standard error text output to the client. It is possible to catch that data with a Stream object using the GetOutputStream() and GetErrorStream() methods. It is also possible to send text to the command's standard input using a stream with the GetInputStream() method. With all these streams, it is often useful to wrap them around a ",(0,r.jsx)(n.code,{children:"System.Text.StreamReader"})," or ",(0,r.jsx)(n.code,{children:"System.Text.StreamWriter"})," object to read and write text lines. See the examples below for details."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ExecuteCommandSession"})," class contains a CommandCompleted Event event that will be triggered when the command has completed on the server. At that point, the channel will have been closed but the possible exit status or exit signal (not all servers supply these values) will still be available to be read."]}),"\n",(0,r.jsx)(n.p,{children:"Another way to watch for the completion of the command is to wait on the SessionCompletedWaitHandle."}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Execute and wait for result"}),(0,r.jsxs)(n.p,{children:["The simplest way to use the ",(0,r.jsx)(n.code,{children:"ExecuteCommandSession"})," class is to start the command and wait for the command to complete."]}),(0,r.jsxs)(a.A,{children:[(0,r.jsx)(o.A,{value:"csharp",label:"C#",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'  using System.IO;\r\n  using Xceed.SSH.Client;\r\n  using Xceed.SSH.Core;\r\n  using Xceed.SSH.Protocols;\r\n  using Xceed.FileSystem;\r\n\r\n  namespace DocumentationExamples.SSH\r\n  {\r\n    public class ExecuteCommandSession3\r\n    {\r\n      public void Example()\r\n      {\r\n        string host = "localhost";\r\n        string username = "normal1";\r\n        string password = "normal1";\r\n\r\n        SSHClient ssh = new SSHClient();\r\n\r\n        // Connect to the host\r\n        ssh.Connect( host );\r\n\r\n        try\r\n        {\r\n          // Log in\r\n          ssh.Authenticate( username, password );\r\n\r\n          // The remote command to execute\r\n          string command = "dir";\r\n\r\n          // Create a session that will execute a remote command\r\n          using( ExecuteCommandSession executeCommandSession = new ExecuteCommandSession( ssh ) )\r\n          {\r\n            // Execute the command on the remote server, waiting until it completes\r\n            Nullable<int> exitStatus = executeCommandSession.ExecuteCommand( command );\r\n\r\n            /* Some servers will return exit information like the return code and the \'signal\'\r\n              if the command fails. */\r\n\r\n            Console.WriteLine( "Command exited with status {0}", exitStatus.HasValue ? exitStatus.ToString() : "(null)" );\r\n\r\n            SSHChannelExitSignal exitSignal = executeCommandSession.ExitSignal;\r\n            if( exitSignal != null )\r\n            {\r\n              Console.WriteLine( "Command exited with signal {0}: {1}", exitSignal.SignalName, exitSignal.ErrorMessage );\r\n            }\r\n          }\r\n        }\r\n        catch( SSHChannelRequestFailedException )\r\n        {\r\n          /* This exception is thrown by ExecuteCommandSession.Connect(). The most common\r\n          * cause is the authenticated user does not have the rights to execute commands\r\n          * on the server. */\r\n        }\r\n        finally\r\n        {\r\n          // Always make sure to disconnect from the server when the connection is no longer needed\r\n          ssh.Disconnect();\r\n        }\r\n      }\r\n    }\r\n  }\n'})})}),(0,r.jsx)(o.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-vb.NET",children:'  Imports System.IO\r\n  Imports Xceed.SSH.Client\r\n  Imports Xceed.SSH.Core\r\n  Imports Xceed.SSH.Protocols\r\n  Imports Xceed.FileSystem\r\n\r\n  Namespace DocumentationExamples.SSH\r\n    Public Class ExecuteCommandSession3\r\n      Public Sub Example()\r\n        Dim host As String = "localhost"\r\n        Dim username As String = "normal1"\r\n        Dim password As String = "normal1"\r\n\r\n        Dim ssh As New SSHClient()\r\n\r\n        \' Connect to the host\r\n        ssh.Connect(host)\r\n\r\n        Try\r\n          \' Log in\r\n          ssh.Authenticate(username, password)\r\n\r\n          \' The remote command to execute\r\n          Dim command As String = "dir"\r\n\r\n          \' Create a session that will execute a remote command\r\n          Using executeCommandSession As New ExecuteCommandSession(ssh)\r\n            \' Execute the command on the remote server, waiting until it completes\r\n            Dim exitStatus As Nullable(Of Integer) = executeCommandSession.ExecuteCommand(command)\r\n\r\n  \'           Some servers will return exit information like the return code and the \'signal\'\r\n  \'             if the command fails. \r\n\r\n            Console.WriteLine("Command exited with status {0}",If(exitStatus.HasValue, exitStatus.ToString(), "(null)"))\r\n\r\n            Dim exitSignal As SSHChannelExitSignal = executeCommandSession.ExitSignal\r\n            If exitSignal IsNot Nothing Then\r\n              Console.WriteLine("Command exited with signal {0}: {1}", exitSignal.SignalName, exitSignal.ErrorMessage)\r\n            End If\r\n          End Using\r\n        Catch e1 As SSHChannelRequestFailedException\r\n  \'         This exception is thrown by ExecuteCommandSession.Connect(). The most common\r\n  \'         * cause is the authenticated user does not have the rights to execute commands\r\n  \'         * on the server. \r\n        Finally\r\n          \' Always make sure to disconnect from the server when the connection is no longer needed\r\n          ssh.Disconnect()\r\n        End Try\r\n      End Sub\r\n    End Class\r\n  End Namespace\n'})})})]})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Fire-and-forget"}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"ExecuteCommandSession"})," class can also be used in a fire-and-forget manner."]}),(0,r.jsxs)(a.A,{children:[(0,r.jsx)(o.A,{value:"csharp",label:"C#",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'  using System.IO;\r\n  using System.Threading.Tasks;\r\n\r\n  using Xceed.SSH.Client;\r\n  using Xceed.SSH.Core;\r\n  using Xceed.SSH.Protocols;\r\n  using Xceed.FileSystem;\r\n\r\n  namespace DocumentationExamples.SSH\r\n  {\r\n    public class ExecuteCommandSession4\r\n    {\r\n      public void Example()\r\n      {\r\n        string host = "localhost";\r\n        string username = "normal1";\r\n        string password = "normal1";\r\n\r\n        // The remote command to execute\r\n        string command = "dir";\r\n\r\n        SSHClient ssh = new SSHClient();\r\n\r\n        // Connect to the host\r\n        ssh.Connect( host );\r\n\r\n        try\r\n        {\r\n          // Log in\r\n          ssh.Authenticate( username, password );\r\n\r\n          Task<Nullable<int>> task = this.ExecuteRemoteCommandAsync( ssh, command );\r\n\r\n          /* TODO: Perform other business that does not require the result of the remote command */\r\n\r\n          /* Now that we need the result from the remote command, we will wait for it */\r\n          Nullable<int> exitStatus = task.Result;\r\n          Console.WriteLine( "Command exited with status {0}", exitStatus.HasValue ? exitStatus.ToString() : "(null)" );\r\n        }\r\n        finally\r\n        {\r\n          // Always make sure to disconnect from the server when the connection is no longer needed\r\n          ssh.Disconnect();\r\n        }\r\n      }\r\n\r\n      private async Task<Nullable<int>> ExecuteRemoteCommandAsync( SSHClient ssh, string command )\r\n      {\r\n        Task<Nullable<int>> executeCommandTask;\r\n        Nullable<int> exitStatus;\r\n\r\n        ExecuteCommandSession executeCommandSession = null;\r\n\r\n        // Create a session that will execute a remote command\r\n        executeCommandSession = new ExecuteCommandSession( ssh );\r\n\r\n        try\r\n        {\r\n          // Start executing the specified command on the remote server\r\n          executeCommandTask = executeCommandSession.ExecuteCommandAsync( command );\r\n        }\r\n        catch( SSHChannelRequestFailedException )\r\n        {\r\n          /* This exception is thrown by ExecuteCommandSession.Connect(). The most common\r\n            * cause is the authenticated user does not have the rights to execute commands\r\n            * on the server. */\r\n\r\n          /* The \'CommandCompleted\' event is not triggered when the request to launch the command fails */\r\n\r\n          // Dispose of the session to free resources\r\n          executeCommandSession.Dispose();\r\n\r\n          // Rethrow the exception\r\n          throw;\r\n        }\r\n\r\n        // Wait for the remote command to complete while allowing the calling method to continue execution\r\n        exitStatus = await executeCommandTask;\r\n\r\n        /* This code will be executed in a background thread from ThreadPool */\r\n\r\n        // Dispose of the session to free resources\r\n        executeCommandSession.Dispose();\r\n\r\n        return exitStatus;\r\n      }\r\n    }\r\n  }\n'})})}),(0,r.jsx)(o.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-vb.NET",children:"  Imports System.IO\r\n  Imports System.Threading.Tasks\r\n\r\n  Imports Xceed.SSH.Client\r\n  Imports Xceed.SSH.Core\r\n  Imports Xceed.SSH.Protocols\r\n  Imports Xceed.FileSystem\r\n\r\n  Namespace DocumentationExamples.SSH\r\n    Public Class ExecuteCommandSession4\r\n      Public Sub Example()\r\n        Dim host As String = \"localhost\"\r\n        Dim username As String = \"normal1\"\r\n        Dim password As String = \"normal1\"\r\n\r\n        ' The remote command to execute\r\n        Dim command As String = \"dir\"\r\n\r\n        Dim ssh As New SSHClient()\r\n\r\n        ' Connect to the host\r\n        ssh.Connect(host)\r\n\r\n        Try\r\n          ' Log in\r\n          ssh.Authenticate(username, password)\r\n\r\n          Dim task As Task(Of Nullable(Of Integer)) = Me.ExecuteRemoteCommandAsync(ssh, command)\r\n\r\n          ' TODO: Perform other business that does not require the result of the remote command \r\n\r\n          ' Now that we need the result from the remote command, we will wait for it \r\n          Dim exitStatus As Nullable(Of Integer) = task.Result\r\n          Console.WriteLine(\"Command exited with status {0}\",If(exitStatus.HasValue, exitStatus.ToString(), \"(null)\"))\r\n        Finally\r\n          ' Always make sure to disconnect from the server when the connection is no longer needed\r\n          ssh.Disconnect()\r\n        End Try\r\n      End Sub\r\n\r\n      Private async Function ExecuteRemoteCommandAsync(ByVal ssh As SSHClient, ByVal command As String) As Task(Of Nullable(Of Integer))\r\n        Dim executeCommandTask As Task(Of Nullable(Of Integer))\r\n        Dim exitStatus As Nullable(Of Integer)\r\n\r\n        Dim executeCommandSession As ExecuteCommandSession = Nothing\r\n\r\n        ' Create a session that will execute a remote command\r\n        executeCommandSession = New ExecuteCommandSession(ssh)\r\n\r\n        Try\r\n          ' Start executing the specified command on the remote server\r\n          executeCommandTask = executeCommandSession.ExecuteCommandAsync(command)\r\n        Catch e1 As SSHChannelRequestFailedException\r\n  '         This exception is thrown by ExecuteCommandSession.Connect(). The most common\r\n  '          * cause is the authenticated user does not have the rights to execute commands\r\n  '          * on the server. \r\n\r\n          ' The 'CommandCompleted' event is not triggered when the request to launch the command fails \r\n\r\n          ' Dispose of the session to free resources\r\n          executeCommandSession.Dispose()\r\n\r\n          ' Rethrow the exception\r\n          Throw\r\n        End Try\r\n\r\n        ' Wait for the remote command to complete while allowing the calling method to continue execution\r\n        exitStatus = await executeCommandTask\r\n\r\n        ' This code will be executed in a background thread from ThreadPool \r\n\r\n        ' Dispose of the session to free resources\r\n        executeCommandSession.Dispose()\r\n\r\n        Return exitStatus\r\n      End Function\r\n    End Class\r\n  End Namespace\n"})})})]})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Capture command output"}),(0,r.jsx)(n.p,{children:"The output of the command can be captured. Here a technique using asynchronous reading is used in order to read output and error text at the same time."}),(0,r.jsx)(n.p,{children:"Also shown in this example is how to pass environment variables to the server."}),(0,r.jsxs)(a.A,{children:[(0,r.jsx)(o.A,{value:"csharp",label:"C#",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'  using System.Collections.Generic;\r\n  using System.IO;\r\n  using System.Threading;\r\n  using System.Threading.Tasks;\r\n\r\n  using Xceed.SSH.Client;\r\n  using Xceed.SSH.Core;\r\n  using Xceed.SSH.Protocols;\r\n  using Xceed.FileSystem;\r\n\r\n  namespace DocumentationExamples.SSH\r\n  {\r\n    public class ExecuteCommandSession1\r\n    {\r\n      public void Example()\r\n      {\r\n        string host = "localhost";\r\n        string username = "normal1";\r\n        string password = "normal1";\r\n\r\n        SSHClient ssh = new SSHClient();\r\n\r\n        // Connect to the host\r\n        ssh.Connect( host );\r\n\r\n        try\r\n        {\r\n          // Log in\r\n          ssh.Authenticate( username, password );\r\n\r\n          // The remote command to execute\r\n          string command = "dir *.*";\r\n\r\n          // Some environment variables\r\n          KeyValuePair<string, string> environmentVariable = new KeyValuePair<string, string>( "MYVARIABLE", "MYVALUE" );\r\n\r\n          // Create a session that will execute a remote command\r\n          using( ExecuteCommandSession executeCommandSession = new ExecuteCommandSession( ssh ) )\r\n          {\r\n            Stream commandOutputStream = null;\r\n            Stream commandErrorStream = null;\r\n\r\n            try\r\n            {\r\n              /* We obtain the output and error streams BEFORE starting the command so that we don\'t\r\n                miss any output. */\r\n\r\n              /* If the CommandOutputStream or the CommandErrorStream object is not taken,\r\n                the component silently discards the incoming data. This might be desirable if\r\n                the output and/or error text is not needed. */\r\n\r\n              // Get the command\'s output stream (standard output)\r\n              commandOutputStream = executeCommandSession.GetOutputStream();\r\n\r\n              // Get the command\'s error stream (standard error)\r\n              commandErrorStream = executeCommandSession.GetErrorStream();\r\n\r\n              /* Now that we are setup the way we want, we can safely start the remote command */\r\n\r\n              // Start executing the specified command on the remote server passing the supplied environment variables to the server\r\n              executeCommandSession.Connect( command, environmentVariable );\r\n\r\n              /* Notice how we wrap the streams with StreamReader objects only after starting the command.\r\n                This guards against the possibility of the StreamReader object calling Stream.Read() before\r\n                we\'ve started the command. */\r\n\r\n              // Wrap a stream reader around the output stream\r\n              System.IO.StreamReader outputReader = new System.IO.StreamReader( commandOutputStream );\r\n\r\n              // Wrap a stream reader around the error stream\r\n              System.IO.StreamReader errorReader = new System.IO.StreamReader( commandErrorStream );\r\n\r\n              // Read a line from the output and error at the same time\r\n              Task<string> readOutputLineTask = outputReader.ReadLineAsync();\r\n              Task<string> readErrorLineTask = errorReader.ReadLineAsync();\r\n\r\n              string line;\r\n\r\n              // While either the output or error streams haven\'t reached end-of-file\r\n              while( readOutputLineTask != null || readErrorLineTask != null )\r\n              {\r\n                // If reading an output line has completed\r\n                if( readOutputLineTask != null && readOutputLineTask.IsCompleted )\r\n                {\r\n                  // Get the line\r\n                  line = readOutputLineTask.Result;\r\n\r\n                  // If we have a line\r\n                  if( line != null )\r\n                  {\r\n                    // Output it to the console\r\n                    Console.WriteLine( line );\r\n\r\n                    // Read another line\r\n                    readOutputLineTask = outputReader.ReadLineAsync();\r\n                  }\r\n                  else\r\n                  {\r\n                    /* We\'ve reached end-of-file. We don\'t want to read again */\r\n                    readOutputLineTask = null;\r\n                  }\r\n                }\r\n\r\n                // If reading an error line has completed\r\n                if( readErrorLineTask != null && readErrorLineTask.IsCompleted )\r\n                {\r\n                  // Get the line\r\n                  line = readErrorLineTask.Result;\r\n\r\n                  // If we have a line\r\n                  if( line != null )\r\n                  {\r\n                    // Output it to the console\r\n                    Console.WriteLine( line );\r\n\r\n                    // Read another line\r\n                    readErrorLineTask = errorReader.ReadLineAsync();\r\n                  }\r\n                  else\r\n                  {\r\n                    /* We\'ve reached end-of-file. We don\'t want to read again */\r\n                    readErrorLineTask = null;\r\n                  }\r\n                }\r\n              }\r\n\r\n              /* Because we\'ve processed the output stream until end-of-file, we are sure that\r\n                the command has completed. No need to wait. \r\n\r\n                However, if accessing the exit status or possible exit signal of the command\r\n                is important to the application, it is best to wait until the command has signaled it\r\n                has completed. At that point, the exit information will have been received. */\r\n\r\n              // Wait until the command has completed\r\n              executeCommandSession.SessionCompletedWaitHandle.WaitOne();\r\n\r\n              /* Some servers will return exit information like the return code and the \'signal\'\r\n                if the command fails. */\r\n\r\n              Nullable<int> exitStatus = executeCommandSession.ExitStatus;\r\n              Console.WriteLine( "Command exited with status {0}", exitStatus.HasValue ? exitStatus.ToString() : "(null)" );\r\n\r\n              SSHChannelExitSignal exitSignal = executeCommandSession.ExitSignal;\r\n              if( exitSignal != null )\r\n              {\r\n                Console.WriteLine( "Command exited with signal {0}: {1}", exitSignal.SignalName, exitSignal.ErrorMessage );\r\n              }\r\n            }\r\n            catch( SSHChannelRequestFailedException )\r\n            {\r\n              /* This exception is thrown by ExecuteCommandSession.Connect(). The most common\r\n              * cause is the authenticated user does not have the rights to execute commands\r\n              * on the server. */\r\n            }\r\n            finally\r\n            {\r\n              if( commandOutputStream != null )\r\n              {\r\n                commandOutputStream.Close();\r\n                commandOutputStream = null;\r\n              }\r\n\r\n              if( commandErrorStream != null )\r\n              {\r\n                commandErrorStream.Close();\r\n                commandErrorStream = null;\r\n              }\r\n            }\r\n          }\r\n\r\n        }\r\n        finally\r\n        {\r\n          // Always make sure to disconnect from the server when the connection is no longer needed\r\n          ssh.Disconnect();\r\n        }\r\n      }\r\n    }\r\n  }\n'})})}),(0,r.jsx)(o.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-vb.NET",children:"  Imports System.Collections.Generic\r\n  Imports System.IO\r\n  Imports System.Threading\r\n  Imports System.Threading.Tasks\r\n\r\n  Imports Xceed.SSH.Client\r\n  Imports Xceed.SSH.Core\r\n  Imports Xceed.SSH.Protocols\r\n  Imports Xceed.FileSystem\r\n\r\n  Namespace DocumentationExamples.SSH\r\n    Public Class ExecuteCommandSession1\r\n      Public Sub Example()\r\n        Dim host As String = \"localhost\"\r\n        Dim username As String = \"normal1\"\r\n        Dim password As String = \"normal1\"\r\n\r\n        Dim ssh As New SSHClient()\r\n\r\n        ' Connect to the host\r\n        ssh.Connect(host)\r\n\r\n        Try\r\n          ' Log in\r\n          ssh.Authenticate(username, password)\r\n\r\n          ' The remote command to execute\r\n          Dim command As String = \"dir *.*\"\r\n\r\n          ' Some environment variables\r\n          Dim environmentVariable As KeyValuePair(Of String, String) = New KeyValuePair(Of String, String)(\"MYVARIABLE\", \"MYVALUE\")\r\n\r\n          ' Create a session that will execute a remote command\r\n          Using executeCommandSession As New ExecuteCommandSession(ssh)\r\n            Dim commandOutputStream As Stream = Nothing\r\n            Dim commandErrorStream As Stream = Nothing\r\n\r\n            Try\r\n  '             We obtain the output and error streams BEFORE starting the command so that we don't\r\n  '               miss any output. \r\n\r\n  '             If the CommandOutputStream or the CommandErrorStream object is not taken,\r\n  '               the component silently discards the incoming data. This might be desirable if\r\n  '               the output and/or error text is not needed. \r\n\r\n              ' Get the command's output stream (standard output)\r\n              commandOutputStream = executeCommandSession.GetOutputStream()\r\n\r\n              ' Get the command's error stream (standard error)\r\n              commandErrorStream = executeCommandSession.GetErrorStream()\r\n\r\n              ' Now that we are setup the way we want, we can safely start the remote command \r\n\r\n              ' Start executing the specified command on the remote server passing the supplied environment variables to the server\r\n              executeCommandSession.Connect(command, environmentVariable)\r\n\r\n  '             Notice how we wrap the streams with StreamReader objects only after starting the command.\r\n  '               This guards against the possibility of the StreamReader object calling Stream.Read() before\r\n  '               we've started the command. \r\n\r\n              ' Wrap a stream reader around the output stream\r\n              Dim outputReader As New System.IO.StreamReader(commandOutputStream)\r\n\r\n              ' Wrap a stream reader around the error stream\r\n              Dim errorReader As New System.IO.StreamReader(commandErrorStream)\r\n\r\n              ' Read a line from the output and error at the same time\r\n              Dim readOutputLineTask As Task(Of String) = outputReader.ReadLineAsync()\r\n              Dim readErrorLineTask As Task(Of String) = errorReader.ReadLineAsync()\r\n\r\n              Dim line As String\r\n\r\n              ' While either the output or error streams haven't reached end-of-file\r\n              Do While readOutputLineTask IsNot Nothing OrElse readErrorLineTask IsNot Nothing\r\n                ' If reading an output line has completed\r\n                If readOutputLineTask IsNot Nothing AndAlso readOutputLineTask.IsCompleted Then\r\n                  ' Get the line\r\n                  line = readOutputLineTask.Result\r\n\r\n                  ' If we have a line\r\n                  If line IsNot Nothing Then\r\n                    ' Output it to the console\r\n                    Console.WriteLine(line)\r\n\r\n                    ' Read another line\r\n                    readOutputLineTask = outputReader.ReadLineAsync()\r\n                  Else\r\n                    ' We've reached end-of-file. We don't want to read again \r\n                    readOutputLineTask = Nothing\r\n                  End If\r\n                End If\r\n\r\n                ' If reading an error line has completed\r\n                If readErrorLineTask IsNot Nothing AndAlso readErrorLineTask.IsCompleted Then\r\n                  ' Get the line\r\n                  line = readErrorLineTask.Result\r\n\r\n                  ' If we have a line\r\n                  If line IsNot Nothing Then\r\n                    ' Output it to the console\r\n                    Console.WriteLine(line)\r\n\r\n                    ' Read another line\r\n                    readErrorLineTask = errorReader.ReadLineAsync()\r\n                  Else\r\n                    ' We've reached end-of-file. We don't want to read again \r\n                    readErrorLineTask = Nothing\r\n                  End If\r\n                End If\r\n              Loop\r\n\r\n  '             Because we've processed the output stream until end-of-file, we are sure that\r\n  '              the command has completed. No need to wait. \r\n  '\r\n  '               However, if accessing the exit status or possible exit signal of the command\r\n  '               is important to the application, it is best to wait until the command has signaled it\r\n  '               has completed. At that point, the exit information will have been received. \r\n\r\n              ' Wait until the command has completed\r\n              executeCommandSession.SessionCompletedWaitHandle.WaitOne()\r\n\r\n  '             Some servers will return exit information like the return code and the 'signal'\r\n  '              if the command fails. \r\n\r\n              Dim exitStatus As Nullable(Of Integer) = executeCommandSession.ExitStatus\r\n              Console.WriteLine(\"Command exited with status {0}\",If(exitStatus.HasValue, exitStatus.ToString(), \"(null)\"))\r\n\r\n              Dim exitSignal As SSHChannelExitSignal = executeCommandSession.ExitSignal\r\n              If exitSignal IsNot Nothing Then\r\n                Console.WriteLine(\"Command exited with signal {0}: {1}\", exitSignal.SignalName, exitSignal.ErrorMessage)\r\n              End If\r\n            Catch e1 As SSHChannelRequestFailedException\r\n  '             This exception is thrown by ExecuteCommandSession.Connect(). The most common\r\n  '             * cause is the authenticated user does not have the rights to execute commands\r\n  '             * on the server. \r\n            Finally\r\n              If commandOutputStream IsNot Nothing Then\r\n                commandOutputStream.Close()\r\n                commandOutputStream = Nothing\r\n              End If\r\n\r\n              If commandErrorStream IsNot Nothing Then\r\n                commandErrorStream.Close()\r\n                commandErrorStream = Nothing\r\n              End If\r\n            End Try\r\n          End Using\r\n\r\n        Finally\r\n          ' Always make sure to disconnect from the server when the connection is no longer needed\r\n          ssh.Disconnect()\r\n        End Try\r\n      End Sub\r\n    End Class\r\n  End Namespace\n"})})})]})]}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Send data to standard input"}),(0,r.jsx)(n.p,{children:"The output of the command can be captured. Here a technique using asynchronous reading is used in order to read output and error text at the same time."}),(0,r.jsxs)(a.A,{children:[(0,r.jsx)(o.A,{value:"csharp",label:"C#",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'  using System.IO;\r\n  using Xceed.SSH.Client;\r\n  using Xceed.SSH.Core;\r\n  using Xceed.SSH.Protocols;\r\n  using Xceed.FileSystem;\r\n\r\n  namespace DocumentationExamples.SSH\r\n  {\r\n    public class ExecuteCommandSession2\r\n    {\r\n      public void Example()\r\n      {\r\n        string host = "localhost";\r\n        string username = "normal1";\r\n        string password = "normal1";\r\n\r\n        SSHClient ssh = new SSHClient();\r\n\r\n        // Connect to the host\r\n        ssh.Connect( host );\r\n\r\n        try\r\n        {\r\n          // Log in\r\n          ssh.Authenticate( username, password );\r\n\r\n          // The remote command to execute\r\n          string command = "copy Test.txt BackTest.txt /-Y";\r\n\r\n          // Create a session that will execute a remote command\r\n          using( ExecuteCommandSession executeCommandSession = new ExecuteCommandSession( ssh ) )\r\n          {\r\n            // Get the command\'s output stream (standard output/stdout)\r\n            Stream commandOutputStream = executeCommandSession.GetOutputStream();\r\n\r\n            // Start executing the specified command on the remote server\r\n            executeCommandSession.Connect( command );\r\n\r\n            // Wrap the output stream into a stream reader\r\n            System.IO.StreamReader reader = new System.IO.StreamReader( commandOutputStream );\r\n\r\n            string line;\r\n\r\n            /* We expect to receive the text\r\n\r\n              Overwrite BackTest.txt? (Yes/No/All):\r\n\r\n              and then the remote console will wait for input. We can\'t call ReadLine() to get\r\n              the question since it does not contain a newline, we would wait forever.\r\n\r\n              Since we know what we\'re going to receive, we\'ll just go-ahead and send the response immediately. */\r\n\r\n            // Get the command\'s input stream (standard input/stdin)\r\n            Stream commandInputStream = executeCommandSession.GetInputStream();\r\n\r\n            // Wrap the input stream into a stream writer\r\n            StreamWriter writer = new StreamWriter( commandInputStream );\r\n\r\n            // Answer the overwrite query\r\n            writer.WriteLine( "y" );\r\n            writer.Flush();\r\n\r\n            // Read the next lines until we reach end-of-file\r\n            while( ( line = reader.ReadLine() ) != null )\r\n            {\r\n              // Output the line\r\n              Console.WriteLine( line );\r\n            }\r\n          }\r\n        }\r\n        catch( SSHChannelRequestFailedException )\r\n        {\r\n          /* This exception is thrown by ExecuteCommandSession.Connect(). The most common\r\n          * cause is the authenticated user does not have the rights to execute commands\r\n          * on the server. */\r\n          }\r\n        finally\r\n        {\r\n          // Always make sure to disconnect from the server when the connection is no longer needed\r\n          ssh.Disconnect();\r\n        }\r\n      }\r\n    }\r\n  }\n'})})}),(0,r.jsx)(o.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-vb.NET",children:"  Imports System.IO\r\n  Imports Xceed.SSH.Client\r\n  Imports Xceed.SSH.Core\r\n  Imports Xceed.SSH.Protocols\r\n  Imports Xceed.FileSystem\r\n\r\n  Namespace DocumentationExamples.SSH\r\n    Public Class ExecuteCommandSession2\r\n      Public Sub Example()\r\n        Dim host As String = \"localhost\"\r\n        Dim username As String = \"normal1\"\r\n        Dim password As String = \"normal1\"\r\n\r\n        Dim ssh As New SSHClient()\r\n\r\n        ' Connect to the host\r\n        ssh.Connect(host)\r\n\r\n        Try\r\n          ' Log in\r\n          ssh.Authenticate(username, password)\r\n\r\n          ' The remote command to execute\r\n          Dim command As String = \"copy Test.txt BackTest.txt /-Y\"\r\n\r\n          ' Create a session that will execute a remote command\r\n          Using executeCommandSession As New ExecuteCommandSession(ssh)\r\n            ' Get the command's output stream (standard output/stdout)\r\n            Dim commandOutputStream As Stream = executeCommandSession.GetOutputStream()\r\n\r\n            ' Start executing the specified command on the remote server\r\n            executeCommandSession.Connect(command)\r\n\r\n            ' Wrap the output stream into a stream reader\r\n            Dim reader As New System.IO.StreamReader(commandOutputStream)\r\n\r\n            Dim line As String\r\n\r\n  '           We expect to receive the text\r\n  '\r\n  '             Overwrite BackTest.txt? (Yes/No/All):\r\n  '\r\n  '             and then the remote console will wait for input. We can't call ReadLine() to get\r\n  '             the question since it does not contain a newline, we would wait forever.\r\n  '\r\n  '             Since we know what we're going to receive, we'll just go-ahead and send the response immediately. \r\n\r\n            ' Get the command's input stream (standard input/stdin)\r\n            Dim commandInputStream As Stream = executeCommandSession.GetInputStream()\r\n\r\n            ' Wrap the input stream into a stream writer\r\n            Dim writer As New StreamWriter(commandInputStream)\r\n\r\n            ' Answer the overwrite query\r\n            writer.WriteLine(\"y\")\r\n            writer.Flush()\r\n\r\n            ' Read the next lines until we reach end-of-file\r\n            line = reader.ReadLine()\r\n            Do While line IsNot Nothing\r\n              ' Output the line\r\n              Console.WriteLine(line)\r\n              line = reader.ReadLine()\r\n            Loop\r\n          End Using\r\n        Catch e1 As SSHChannelRequestFailedException\r\n  '         This exception is thrown by ExecuteCommandSession.Connect(). The most common\r\n  '         * cause is the authenticated user does not have the rights to execute commands\r\n  '         * on the server. \r\n        Finally\r\n          ' Always make sure to disconnect from the server when the connection is no longer needed\r\n          ssh.Disconnect()\r\n        End Try\r\n      End Sub\r\n    End Class\r\n  End Namespace\n"})})})]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>o});t(96540);var r=t(34164);const s={tabItem:"tabItem_Ymn6"};var a=t(74848);function o(e){let{children:n,hidden:t,className:o}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,o),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>v});var r=t(96540),s=t(34164),a=t(23104),o=t(56347),i=t(205),m=t(57485),c=t(31682),l=t(70679);function d(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const s=(0,o.W6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,m.aZ)(a),(0,r.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,e),s.replace({...s.location,search:n.toString()})}),[a,s])]}function S(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,a=u(e),[o,m]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:a}))),[c,d]=p({queryString:t,groupId:s}),[S,x]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,a]=(0,l.Dv)(t);return[s,(0,r.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:s}),g=(()=>{const e=c??S;return h({value:e,tabValues:a})?e:null})();(0,i.A)((()=>{g&&m(g)}),[g]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);m(e),d(e),x(e)}),[d,x,a]),tabValues:a}}var x=t(92303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(74848);function w(e){let{className:n,block:t,selectedValue:r,selectValue:o,tabValues:i}=e;const m=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),l=e=>{const n=e.currentTarget,t=m.indexOf(n),s=i[t].value;s!==r&&(c(n),o(s))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=m.indexOf(e.currentTarget)+1;n=m[t]??m[0];break}case"ArrowLeft":{const t=m.indexOf(e.currentTarget)-1;n=m[t]??m[m.length-1];break}}n?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:a}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>m.push(e),onKeyDown:d,onClick:l,...a,className:(0,s.A)("tabs__item",g.tabItem,a?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function C(e){let{lazy:n,children:t,selectedValue:a}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function b(e){const n=S(e);return(0,f.jsxs)("div",{className:(0,s.A)("tabs-container",g.tabList),children:[(0,f.jsx)(w,{...n,...e}),(0,f.jsx)(C,{...n,...e})]})}function v(e){const n=(0,x.A)();return(0,f.jsx)(b,{...e,children:d(e.children)},String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(96540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);