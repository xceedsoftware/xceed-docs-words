"use strict";(self.webpackChunkxceed_docs_words=self.webpackChunkxceed_docs_words||[]).push([[1882],{5240:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var r=n(4848),i=n(8453),a=n(1470),s=n(9365);const o={},l="Handling archives with directory traversal items (ZipSlip)",c={id:"basic-concepts/unzipping/handling-archives-with-directory",title:"Handling archives with directory traversal items (ZipSlip)",description:"Introduction",source:"@site/zip/basic-concepts/unzipping/handling-archives-with-directory.md",sourceDirName:"basic-concepts/unzipping",slug:"/basic-concepts/unzipping/handling-archives-with-directory",permalink:"/xceed-docs-words/zip/basic-concepts/unzipping/handling-archives-with-directory",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebarzip",previous:{title:"Extracting items from a generic stream",permalink:"/xceed-docs-words/zip/basic-concepts/unzipping/unzipping-items-from-zip-file"},next:{title:"QuickZip class",permalink:"/xceed-docs-words/zip/basic-concepts/quick-zip"}},d={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Is this cause for worry",id:"is-this-cause-for-worry",level:2},{value:"Which components are affected",id:"which-components-are-affected",level:2},{value:"Which components are not affected",id:"which-components-are-not-affected",level:2},{value:"Example solution",id:"example-solution",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"handling-archives-with-directory-traversal-items-zipslip",children:"Handling archives with directory traversal items (ZipSlip)"})}),"\n",(0,r.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(t.p,{children:'When unzipping, while very rare, some archives can have items whose names contain directory traversal elements like the parent directory "..". With enough of these put together, the effective target file can be computed to be outside the base destination folder specified for the unzip operation.'}),"\n",(0,r.jsxs)(t.p,{children:["The Zip specification does allow directory traversal elements in the name of zipped items. As such, those archives are not considered invalid and the components support them. However, the construct can be abused to overwrite important files outside the control of an application. This has been called by security researchers the ",(0,r.jsx)(t.a,{href:"https://snyk.io/research/zip-slip-vulnerability",children:"Zip Slip vulnerability"})," in June 2018."]}),"\n",(0,r.jsx)(t.h2,{id:"is-this-cause-for-worry",children:"Is this cause for worry"}),"\n",(0,r.jsx)(t.p,{children:"If an application unzips archives that have been created by Xceed components or other reputable zip tools and libraries, there is no cause to worry. These tools do not allow the creation of zip archive that contain directory traversal elements. This is the overwhelming majority of scenarios."}),"\n",(0,r.jsx)(t.p,{children:"If an application is meant to unzip archives receives from unknown sources, then measures can be taken to prevent files from being created outside the destination directory if the behavior is not desired."}),"\n",(0,r.jsx)(t.h2,{id:"which-components-are-affected",children:"Which components are affected"}),"\n",(0,r.jsx)(t.p,{children:"Xceed Zip for .NET, Xceed Zip for Xamarin, Xceed Zip for .NET Standard, Xceed Zip for COM/ActiveX and Xceed Zip for x64 will all honor the directory traversal elements in a zipped item name when the automatic unzip methods like CopyTo() and MoveTo() are used."}),"\n",(0,r.jsx)(t.p,{children:"If an application uses its own custom code to identity and select items to be unzipped, then the vulnerability can be avoided by checking the effective destination path to see if it is outside the base destination folder."}),"\n",(0,r.jsx)(t.p,{children:"When using automatic methods, an application can monitor the destination path of each item that will be unzipped and exclude those that would fall outside the base destination folder."}),"\n",(0,r.jsx)(t.h2,{id:"which-components-are-not-affected",children:"Which components are not affected"}),"\n",(0,r.jsx)(t.p,{children:"Xceed Real-Time Zip for .NET, Xceed Real-Time Zip for Xamarin, Xceed Real-Time Zip for .NET Standard and Xceed Real-Time for Silverlight are not affected directly because they do not offer an automatic way to unzip an archive."}),"\n",(0,r.jsx)(t.p,{children:"It is up to the application code to validate the destination path of each item unzipped from the archive."}),"\n",(0,r.jsx)(t.h2,{id:"example-solution",children:"Example solution"}),"\n",(0,r.jsx)(t.p,{children:"The AddingItemToProcess event can be used to filter out potentially dangerous zipped items whose names contain relative path elements (like ....) that, during an unzip operation can create or overwrite files outside of the base destination folder."}),"\n",(0,r.jsxs)(a.A,{children:[(0,r.jsx)(s.A,{value:"csharp",label:"C#",default:!0,children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",children:'public static void ZipSlip()\r\n{ \r\n  AbstractFile zipFile = new DiskFile( "ZipSlip1.zip" );\r\n\r\n  if( !zipFile.Exists )\r\n    throw new InvalidProgramException( "The zip file must exist for this example to work correctly" );\r\n\r\n  // Create a logical zip archive around the zip file\r\n  ZipArchive zip = new ZipArchive( zipFile );\r\n\r\n  // Create a FileSystemEvents object\r\n  FileSystemEvents events = new FileSystemEvents();\r\n\r\n  // Subscribe to the AddingItemToProcess event\r\n  events.AddingItemToProcess += OnAddingItemToProcessExclude;\r\n\r\n  // Setup a destination folder\r\n  AbstractFolder destinationFolder = new DiskFolder( @"D:\\ZipSlip\\Output" );\r\n\r\n  // User the destination folder as userData\r\n  object userData = destinationFolder;\r\n\r\n  // Unzip the contents of the archive\r\n  zip.CopyFilesTo( events, userData, destinationFolder, true, true );\r\n}\r\n\r\nprivate static void OnAddingItemToProcessExclude( object sender, ItemProcessingEventArgs e )\r\n{\r\n  // Retrieve the destination folder from the user data\r\n  AbstractFolder destinationFolder = ( AbstractFolder ) e.UserData;\r\n  string destinationFullname = destinationFolder.FullName;\r\n\r\n  FileSystemItem destinationItem = e.TargetItem;\r\n  string targetPath = destinationItem.FullName;\r\n\r\n  // If the target path does not start with the destination path\r\n  if( !targetPath.StartsWith( destinationFullname ) )\r\n  {\r\n    /* The zipped item contains relative path modifiers that make the destination\r\n      go outside the base destination path. In some controlled situations, that\r\n      might be ok, but we chose not to allow it here. We will exclude this item. */\r\n\r\n    e.Excluded = true;\r\n  }\r\n}\n'})})}),(0,r.jsx)(s.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-vb.NET",children:"  Public Shared Sub ZipSlip()\r\n  Dim zipFile As AbstractFile = New DiskFile(\"ZipSlip1.zip\")\r\n\r\n  If (Not zipFile.Exists) Then\r\n    Throw New InvalidProgramException(\"The zip file must exist for this example to work correctly\")\r\n  End If\r\n\r\n  ' Create a logical zip archive around the zip file\r\n  Dim zip As New ZipArchive(zipFile)\r\n\r\n  ' Create a FileSystemEvents object\r\n  Dim events As New FileSystemEvents()\r\n\r\n  ' Subscribe to the AddingItemToProcess event\r\n  AddHandler events.AddingItemToProcess, AddressOf OnAddingItemToProcessExclude\r\n\r\n  ' Setup a destination folder\r\n  Dim destinationFolder As AbstractFolder = New DiskFolder(\"D:\\ZipSlip\\Output\")\r\n\r\n  ' User the destination folder as userData\r\n  Dim userData As Object = destinationFolder\r\n\r\n  ' Unzip the contents of the archive\r\n  zip.CopyFilesTo(events, userData, destinationFolder, True, True)\r\nEnd Sub\r\n\r\nPrivate Shared Sub OnAddingItemToProcessExclude(ByVal sender As Object, ByVal e As ItemProcessingEventArgs)\r\n  ' Retrieve the destination folder from the user data\r\n  Dim destinationFolder As AbstractFolder = CType(e.UserData, AbstractFolder)\r\n  Dim destinationFullname As String = destinationFolder.FullName\r\n\r\n  Dim destinationItem As FileSystemItem = e.TargetItem\r\n  Dim targetPath As String = destinationItem.FullName\r\n\r\n  ' If the target path does not start with the destination path\r\n  If (Not targetPath.StartsWith(destinationFullname)) Then\r\n    ' The zipped item contains relative path modifiers that make the destination\r\n    ' go outside the base destination path. In some controlled situations, that\r\n    ' might be ok, but we chose not to allow it here. We will exclude this item. \r\n\r\n    e.Excluded = True\r\n  End If\r\nEnd Sub\n"})})})]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>s});n(6540);var r=n(4164);const i={tabItem:"tabItem_Ymn6"};var a=n(4848);function s(e){let{children:t,hidden:n,className:s}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,s),hidden:n,children:t})}},1470:(e,t,n)=>{n.d(t,{A:()=>I});var r=n(6540),i=n(4164),a=n(3104),s=n(6347),o=n(205),l=n(7485),c=n(1682),d=n(679);function u(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:i}}=e;return{value:t,label:n,attributes:r,default:i}}))}(n);return function(e){const t=(0,c.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const i=(0,s.W6)(),a=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(a),(0,r.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(i.location.search);t.set(a,e),i.replace({...i.location,search:t.toString()})}),[a,i])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:i}=e,a=h(e),[s,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:a}))),[c,u]=m({queryString:n,groupId:i}),[f,v]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,a]=(0,d.Dv)(n);return[i,(0,r.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:i}),b=(()=>{const e=c??f;return p({value:e,tabValues:a})?e:null})();(0,o.A)((()=>{b&&l(b)}),[b]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),v(e)}),[u,v,a]),tabValues:a}}var v=n(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=n(4848);function w(e){let{className:t,block:n,selectedValue:r,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),d=e=>{const t=e.currentTarget,n=l.indexOf(t),i=o[n].value;i!==r&&(c(t),s(i))},u=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},t),children:o.map((e=>{let{value:t,label:n,attributes:a}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>l.push(e),onKeyDown:u,onClick:d,...a,className:(0,i.A)("tabs__item",b.tabItem,a?.className,{"tabs__item--active":r===t}),children:n??t},t)}))})}function x(e){let{lazy:t,children:n,selectedValue:a}=e;const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:s.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function y(e){const t=f(e);return(0,g.jsxs)("div",{className:(0,i.A)("tabs-container",b.tabList),children:[(0,g.jsx)(w,{...t,...e}),(0,g.jsx)(x,{...t,...e})]})}function I(e){const t=(0,v.A)();return(0,g.jsx)(y,{...e,children:u(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(6540);const i={},a=r.createContext(i);function s(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);