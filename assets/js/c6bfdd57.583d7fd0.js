"use strict";(self.webpackChunkxceed_libs_doc=self.webpackChunkxceed_libs_doc||[]).push([[7452],{81611:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>f,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var i=n(74848),r=n(28453),c=n(11470),a=n(19365);const o={},s="Secure FTP (SSL/TLS)",l={id:"basic-concepts/ftp-capabilities/secure-ftp",title:"Secure FTP (SSL/TLS)",description:"As of version 2.0, Xceed FTP for .NET supports both SSL 3.0 and TLS (SSL 3.1). SSL and TLS are protocols layered above connection protocols (such as TCP /IP ) but beneath application protocols (such as FTP) that provide encrypted, authenticated communications between a client and a server.",source:"@site/ftp/basic-concepts/ftp-capabilities/secure-ftp.md",sourceDirName:"basic-concepts/ftp-capabilities",slug:"/basic-concepts/ftp-capabilities/secure-ftp",permalink:"/xceed-libs-doc/ftp/basic-concepts/ftp-capabilities/secure-ftp",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebarftp",previous:{title:"Using the FXP Protocol",permalink:"/xceed-libs-doc/ftp/basic-concepts/ftp-capabilities/using-fxp-protocol"},next:{title:"SFTP Capabilities",permalink:"/xceed-libs-doc/ftp/basic-concepts/sftp-capabilities/overview"}},f={},h=[{value:"Implicit versus explicit SSL connections (per RFC 2228)",id:"implicit-versus-explicit-ssl-connections-per-rfc-2228",level:2},{value:"Certificates",id:"certificates",level:2},{value:"SSL demonstration",id:"ssl-demonstration",level:2},{value:"Client Certificates",id:"client-certificates",level:2}];function d(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"secure-ftp-ssltls",children:"Secure FTP (SSL/TLS)"})}),"\n",(0,i.jsx)(t.p,{children:"As of version 2.0, Xceed FTP for .NET supports both SSL 3.0 and TLS (SSL 3.1). SSL and TLS are protocols layered above connection protocols (such as TCP /IP ) but beneath application protocols (such as FTP) that provide encrypted, authenticated communications between a client and a server."}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:"Secure FTP is not supported by Xceed FTP for .NET Compact Framework."})}),"\n",(0,i.jsx)(t.h2,{id:"implicit-versus-explicit-ssl-connections-per-rfc-2228",children:"Implicit versus explicit SSL connections (per RFC 2228)"}),"\n",(0,i.jsxs)(t.p,{children:["Connecting securely and authenticating are two distinct methods of establishing a secure connection with an FTP server. In the first case, the Secure FTP server may require an SSL connection to be established first, before it sends its initial welcome message. This is called an ",(0,i.jsx)(t.strong,{children:"implicit"})," SSL connection. In the second case,   the connection is established in clear text and a special FTP command must be sent to the Secure FTP server to change the connection into a secure connection. This is called an ",(0,i.jsx)(t.strong,{children:"explicit"})," SSL connection."]}),"\n",(0,i.jsxs)(t.p,{children:["In most cases, FTP servers that support SSL authentication will accept a normal connection on port 21. Once the connection is established, it is necessary to authenticate before logging in, using the ",(0,i.jsx)(t.code,{children:"Authenticate"})," method. When securing the connection explicitly, it is also possible to secure data connections using the overload of the ",(0,i.jsx)(t.code,{children:"Authenticate"})," method which requires a ",(0,i.jsx)(t.code,{children:"DataChannelProtection"})," enum as a parameter."]}),"\n",(0,i.jsx)(t.p,{children:"Servers that require an implicit SSL connection usually listen on port 990 rather than 21."}),"\n",(0,i.jsx)(t.h2,{id:"certificates",children:"Certificates"}),"\n",(0,i.jsx)(t.p,{children:"A certificate is a digitally signed statement from one entity (person, company, etc.) that states that the public key of another entity has a particular value. Trusting the certificate's signature implies that you trust that the association in the certificate between the specified public key and the other entity is authentic."}),"\n",(0,i.jsx)(t.p,{children:"The certificate that is received from the FTP server is verified against the VerificationFlags provided at connection or authentication. By default, if a certificate received from an FTP server contains anomalies, it will be rejected. If no anomalies are detected, it will be accepted."}),"\n",(0,i.jsxs)(t.p,{children:["To reduce the severity with which the FTP server's certificate is verified, the ",(0,i.jsx)(t.code,{children:"CertificateReceived"})," event must be handled and the verification flags modified. Once the verification flags have been modified, the verification action must be set to VerifyAgain to verify the server's certificate again. To indiscriminately accept the certificate received from the FTP sever, regardless of anomalies, the verification action must be set to Accept."]}),"\n",(0,i.jsx)(t.p,{children:"Keep in mind that the server certificate that was accepted during the command channel connection will be the only certificate that will be accepted during the data channel connection."}),"\n",(0,i.jsxs)(t.p,{children:["Client certificates can be sent to the FTP server when connecting (implicit SSL), when authenticating (explicit SSL), or via the ",(0,i.jsx)(t.code,{children:"CertificateRequired"})," event. If the FTP server rejects the client certificate (or no certificate was provided when connecting or authenticating), the ",(0,i.jsx)(t.code,{children:"CertificateRequired"})," event will be raised allowing a new certificate to be provided. If the same invalid certificate is provided in the ",(0,i.jsx)(t.code,{children:"CertificateReceived"})," event, an exception will be thrown."]}),"\n",(0,i.jsxs)(t.p,{children:["Client certificates are often optional. It depends on how the FTP server has been configured. If the ",(0,i.jsx)(t.code,{children:"CertificateRequired"})," event is triggered, the server is informing you that you must supply a certificate for the connection to be successful."]}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsxs)(t.p,{children:["If different invalid certificates are provided in the ",(0,i.jsx)(t.code,{children:"CertificateRequired"})," event, a loop will occur!"]})}),"\n",(0,i.jsx)(t.p,{children:"Keep in mind that the client certificate that was used for the command channel connection will be the same one that is used for the data channel connection."}),"\n",(0,i.jsx)(t.h2,{id:"ssl-demonstration",children:"SSL demonstration"}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Example: Implicit SSL connection"}),(0,i.jsxs)(t.p,{children:["The following example demonstrates how to use an ",(0,i.jsx)(t.strong,{children:"implicit"})," SSL connection to securely connect to, log into, and disconnect from a secure FTP server using the ",(0,i.jsx)(t.code,{children:"FtpClient"})," interface. We will handle the ",(0,i.jsx)(t.code,{children:"CertificateReceived"})," event to validate the certificate received from the FTP server. For an explicit SSL connection demonstration, refer to the Quick Tour Sample. An example using the ",(0,i.jsx)(t.code,{children:"FtpConnection"})," class follows below."]}),(0,i.jsxs)(c.A,{children:[(0,i.jsx)(a.A,{value:"csharp",label:"C#",default:!0,children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'    static void ImplicitSSLExample()\r\n    {\r\n      try\r\n      {\r\n        FtpClient ftp = new FtpClient();\r\n        //ftp.TraceWriter = Console.Out;\r\n\r\n        // Subscribe to the CertificateReceived event\r\n        ftp.CertificateReceived += new CertificateReceivedEventHandler( OnCertificateReceived );\r\n\r\n        // Pick an authentication method\r\n        AuthenticationMethod authenticationMethod = AuthenticationMethod.Ssl;\r\n\r\n        // Pick verification flags. If unsure, pick \'None\'.\r\n        VerificationFlags verificationFlags = VerificationFlags.None;\r\n\r\n        // Supply a client certificate to submit to the server. This example doesn\'t use one\r\n        Certificate clientCertificate = null;\r\n\r\n        // Connect implicitly to the server using encryption. Notice the port number reserved for this\r\n        // This form always enables encryption for the data channel (for file transfers)\r\n        ftp.Connect( "localhost", 990, authenticationMethod, verificationFlags, clientCertificate );\r\n\r\n        try\r\n        {\r\n          // Login. The exchanged information will be encrypted\r\n          ftp.Login( "username", "password" );\r\n\r\n          /* Perform your file transfers */\r\n        }\r\n        finally\r\n        {\r\n          // Make sure we always disconnect\r\n          ftp.Disconnect();\r\n\r\n          ftp.CertificateReceived -= new CertificateReceivedEventHandler( OnCertificateReceived );\r\n        }\r\n      }\r\n      catch( Exception exception )\r\n      {\r\n        // Output some information about it\r\n        Console.WriteLine( "--\x3e{0}: {1}\\n{2}", exception.GetType().Name, exception.Message, exception.StackTrace );\r\n\r\n        // Fetch the inner exception\r\n        exception = exception.InnerException;\r\n\r\n        // While there is an exception\r\n        while( exception != null )\r\n        {\r\n          // Output some information about it\r\n          Console.WriteLine( "--\x3eInner exception: {0}: {1}\\n{2}", exception.GetType().Name, exception.Message, exception.StackTrace );\r\n\r\n          // Fetch the inner exception\r\n          exception = exception.InnerException;\r\n        }\r\n      }\r\n    }\r\n\r\n    static void OnCertificateReceived( object sender, CertificateReceivedEventArgs e )\r\n    {\r\n      // The Status argument property tells you if the server certificate was accepted\r\n      // based on the VerificationFlags provided in the call to Connect().\r\n      if( e.Status != VerificationStatus.ValidCertificate )\r\n      {\r\n        Console.WriteLine( "The server certificate is invalid: {0}", e.Status.ToString() );\r\n        Console.WriteLine( e.ServerCertificate.ToString() );\r\n\r\n        // You have three choices here:\r\n        //\r\n        //  1) Refuse the certificate by setting e.Action to VerificationAction.Reject,\r\n        //      thus making the authentication fail. This is e.Action\'s default value\r\n        //      when the server certificate isn\'t valid.\r\n        //\r\n        //  2) Set e.Flags to less restrictive criterion and ask the library to\r\n        //      validate the certificate again by setting e.Action to\r\n        //      VerificationAction.VerifyAgain.\r\n        //\r\n        //  3) Force the library to accept this certificate by setting e.Action to\r\n        //      VerificationAction.Accept.\r\n        //\r\n        // We\'ll do #1 or #3, depending on the user\'s answer.\r\n\r\n        Console.WriteLine( "Do you want to accept this certificate anyway? [Y/N]" );\r\n\r\n        int answer = Console.Read();\r\n        if( ( answer == \'y\' ) || ( answer == \'Y\' ) )\r\n        {\r\n          e.Action = VerificationAction.Accept;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        // e.Action\'s default value is VerificationAction.Accept\r\n        Console.WriteLine( "Valid certificate received from server." );\r\n      }\r\n    }\n'})})}),(0,i.jsx)(a.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-vb.NET",children:"    Private Shared Sub ImplicitSSLExample()\r\n    Try\r\n      Dim ftp As New FtpClient()\r\n      'ftp.TraceWriter = Console.Out;\r\n\r\n      ' Subscribe to the CertificateReceived event\r\n      AddHandler ftp.CertificateReceived, AddressOf OnCertificateReceived\r\n\r\n      ' Pick an authentication method\r\n      Dim authenticationMethod As AuthenticationMethod = AuthenticationMethod.Ssl\r\n\r\n      ' Pick verification flags. If unsure, pick 'None'.\r\n      Dim verificationFlags As VerificationFlags = VerificationFlags.None\r\n\r\n      ' Supply a client certificate to submit to the server. This example doesn't use one\r\n      Dim clientCertificate As Certificate = Nothing\r\n\r\n      ' Connect implicitly to the server using encryption. Notice the port number reserved for this\r\n      ' This form always enables encryption for the data channel (for file transfers)\r\n      ftp.Connect(\"localhost\", 990, authenticationMethod, verificationFlags, clientCertificate)\r\n\r\n      Try\r\n        ' Login. The exchanged information will be encrypted\r\n        ftp.Login(\"username\", \"password\")\r\n\r\n        ' Perform your file transfers \r\n      Finally\r\n        ' Make sure we always disconnect\r\n        ftp.Disconnect()\r\n\r\n        RemoveHandler ftp.CertificateReceived, AddressOf OnCertificateReceived\r\n      End Try\r\n    Catch exception As Exception\r\n      ' Output some information about it\r\n      Console.WriteLine(\"--\x3e{0}: {1}\" & Constants.vbLf & \"{2}\", exception.GetType().Name, exception.Message, exception.StackTrace)\r\n\r\n      ' Fetch the inner exception\r\n      exception = exception.InnerException\r\n\r\n      ' While there is an exception\r\n      Do While exception IsNot Nothing\r\n        ' Output some information about it\r\n        Console.WriteLine(\"--\x3eInner exception: {0}: {1}\" & Constants.vbLf & \"{2}\", exception.GetType().Name, exception.Message, exception.StackTrace)\r\n\r\n        ' Fetch the inner exception\r\n        exception = exception.InnerException\r\n      Loop\r\n    End Try\r\n  End Sub\r\n\r\n  Private Shared Sub OnCertificateReceived(ByVal sender As Object, ByVal e As CertificateReceivedEventArgs)\r\n    ' The Status argument property tells you if the server certificate was accepted\r\n    ' based on the VerificationFlags provided in the call to Connect().\r\n    If e.Status <> VerificationStatus.ValidCertificate Then\r\n      Console.WriteLine(\"The server certificate is invalid: {0}\", e.Status.ToString())\r\n      Console.WriteLine(e.ServerCertificate.ToString())\r\n\r\n      ' You have three choices here:\r\n      '\r\n      '  1) Refuse the certificate by setting e.Action to VerificationAction.Reject,\r\n      '      thus making the authentication fail. This is e.Action's default value\r\n      '      when the server certificate isn't valid.\r\n      '\r\n      '  2) Set e.Flags to less restrictive criterion and ask the library to\r\n      '      validate the certificate again by setting e.Action to\r\n      '      VerificationAction.VerifyAgain.\r\n      '\r\n      '  3) Force the library to accept this certificate by setting e.Action to\r\n      '      VerificationAction.Accept.\r\n      '\r\n      ' We'll do #1 or #3, depending on the user's answer.\r\n\r\n      Console.WriteLine(\"Do you want to accept this certificate anyway? [Y/N]\")\r\n\r\n      Dim answer As Integer = Console.Read()\r\n      If (answer = AscW(\"y\"c)) OrElse (answer = AscW(\"Y\"c)) Then\r\n        e.Action = VerificationAction.Accept\r\n      End If\r\n    Else\r\n      ' e.Action's default value is VerificationAction.Accept\r\n      Console.WriteLine(\"Valid certificate received from server.\")\r\n    End If\r\n  End Sub\n"})})})]})]}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Example: Explicit SSL connection"}),(0,i.jsx)(t.p,{children:"Here, an explicit SSL connection is made:"}),(0,i.jsxs)(c.A,{children:[(0,i.jsx)(a.A,{value:"csharp",label:"C#",default:!0,children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'    static void ExplicitSSLExample()\r\n    {\r\n      try\r\n      {\r\n        FtpClient ftp = new FtpClient();\r\n        //ftp.TraceWriter = Console.Out;\r\n\r\n        // Subscribe to the CertificateReceived event\r\n        ftp.CertificateReceived += new CertificateReceivedEventHandler( OnCertificateReceived );\r\n\r\n        // Connect to the server normally, unencrypted, at the usual ftp port\r\n        ftp.Connect( "localhost", 21 );\r\n\r\n        try\r\n        {\r\n          // Pick an authentication method\r\n          AuthenticationMethod authenticationMethod = AuthenticationMethod.Ssl;\r\n\r\n          // Pick verification flags. If unsure, pick \'None\'.\r\n          VerificationFlags verificationFlags = VerificationFlags.None;\r\n\r\n          // Supply a client certificate to submit to the server. This example doesn\'t use one\r\n          Certificate clientCertificate = null;\r\n\r\n          // Decide if the data channel (for file transfers) will be encrypted or not\r\n          DataChannelProtection dataChannelProtection = DataChannelProtection.Private;\r\n\r\n          // Authenticate and encrypt the connection\r\n          ftp.Authenticate( authenticationMethod, verificationFlags, clientCertificate, dataChannelProtection );\r\n\r\n          // Login. The exchanged information will be encrypted\r\n          ftp.Login( "username", "password" );\r\n\r\n          /* Perform your file transfers */\r\n        }\r\n        finally\r\n        {\r\n          // Make sure we always disconnect\r\n          ftp.Disconnect();\r\n\r\n          ftp.CertificateReceived -= new CertificateReceivedEventHandler( OnCertificateReceived );\r\n        }\r\n      }\r\n      catch( Exception exception )\r\n      {\r\n        // Output some information about it\r\n        Console.WriteLine( "--\x3e{0}: {1}\\n{2}", exception.GetType().Name, exception.Message, exception.StackTrace );\r\n\r\n        // Fetch the inner exception\r\n        exception = exception.InnerException;\r\n\r\n        // While there is an exception\r\n        while( exception != null )\r\n        {\r\n          // Output some information about it\r\n          Console.WriteLine( "--\x3eInner exception: {0}: {1}\\n{2}", exception.GetType().Name, exception.Message, exception.StackTrace );\r\n\r\n          // Fetch the inner exception\r\n          exception = exception.InnerException;\r\n        }\r\n      }\r\n    }\r\n\r\n    static void OnCertificateReceived( object sender, CertificateReceivedEventArgs e )\r\n    {\r\n      // The Status argument property tells you if the server certificate was accepted\r\n      // based on the VerificationFlags provided in the call to Connect().\r\n      if( e.Status != VerificationStatus.ValidCertificate )\r\n      {\r\n        Console.WriteLine( "The server certificate is invalid: {0}", e.Status.ToString() );\r\n        Console.WriteLine( e.ServerCertificate.ToString() );\r\n\r\n        // You have three choices here:\r\n        //\r\n        //  1) Refuse the certificate by setting e.Action to VerificationAction.Reject,\r\n        //      thus making the authentication fail. This is e.Action\'s default value\r\n        //      when the server certificate isn\'t valid.\r\n        //\r\n        //  2) Set e.Flags to less restrictive criterion and ask the library to\r\n        //      validate the certificate again by setting e.Action to\r\n        //      VerificationAction.VerifyAgain.\r\n        //\r\n        //  3) Force the library to accept this certificate by setting e.Action to\r\n        //      VerificationAction.Accept.\r\n        //\r\n        // We\'ll do #1 or #3, depending on the user\'s answer.\r\n\r\n        Console.WriteLine( "Do you want to accept this certificate anyway? [Y/N]" );\r\n\r\n        int answer = Console.Read();\r\n        if( ( answer == \'y\' ) || ( answer == \'Y\' ) )\r\n        {\r\n          e.Action = VerificationAction.Accept;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        // e.Action\'s default value is VerificationAction.Accept\r\n        Console.WriteLine( "Valid certificate received from server." );\r\n      }\r\n    }\n'})})}),(0,i.jsx)(a.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-vb.NET",children:"    Private Shared Sub ExplicitSSLExample()\r\n    Try\r\n      Dim ftp As New FtpClient()\r\n      'ftp.TraceWriter = Console.Out;\r\n\r\n      ' Subscribe to the CertificateReceived event\r\n      AddHandler ftp.CertificateReceived, AddressOf OnCertificateReceived\r\n\r\n      ' Connect to the server normally, unencrypted, at the usual ftp port\r\n      ftp.Connect(\"localhost\", 21)\r\n\r\n      Try\r\n        ' Pick an authentication method\r\n        Dim authenticationMethod As AuthenticationMethod = AuthenticationMethod.Ssl\r\n\r\n        ' Pick verification flags. If unsure, pick 'None'.\r\n        Dim verificationFlags As VerificationFlags = VerificationFlags.None\r\n\r\n        ' Supply a client certificate to submit to the server. This example doesn't use one\r\n        Dim clientCertificate As Certificate = Nothing\r\n\r\n        ' Decide if the data channel (for file transfers) will be encrypted or not\r\n        Dim dataChannelProtection As DataChannelProtection = DataChannelProtection.Private\r\n\r\n        ' Authenticate and encrypt the connection\r\n        ftp.Authenticate(authenticationMethod, verificationFlags, clientCertificate, dataChannelProtection)\r\n\r\n        ' Login. The exchanged information will be encrypted\r\n        ftp.Login(\"username\", \"password\")\r\n\r\n        ' Perform your file transfers \r\n      Finally\r\n        ' Make sure we always disconnect\r\n        ftp.Disconnect()\r\n\r\n        RemoveHandler ftp.CertificateReceived, AddressOf OnCertificateReceived\r\n      End Try\r\n    Catch exception As Exception\r\n      ' Output some information about it\r\n      Console.WriteLine(\"--\x3e{0}: {1}\" & Constants.vbLf & \"{2}\", exception.GetType().Name, exception.Message, exception.StackTrace)\r\n\r\n      ' Fetch the inner exception\r\n      exception = exception.InnerException\r\n\r\n      ' While there is an exception\r\n      Do While exception IsNot Nothing\r\n        ' Output some information about it\r\n        Console.WriteLine(\"--\x3eInner exception: {0}: {1}\" & Constants.vbLf & \"{2}\", exception.GetType().Name, exception.Message, exception.StackTrace)\r\n\r\n        ' Fetch the inner exception\r\n        exception = exception.InnerException\r\n      Loop\r\n    End Try\r\n  End Sub\r\n\r\n  Private Shared Sub OnCertificateReceived(ByVal sender As Object, ByVal e As CertificateReceivedEventArgs)\r\n    ' The Status argument property tells you if the server certificate was accepted\r\n    ' based on the VerificationFlags provided in the call to Connect().\r\n    If e.Status <> VerificationStatus.ValidCertificate Then\r\n      Console.WriteLine(\"The server certificate is invalid: {0}\", e.Status.ToString())\r\n      Console.WriteLine(e.ServerCertificate.ToString())\r\n\r\n      ' You have three choices here:\r\n      '\r\n      '  1) Refuse the certificate by setting e.Action to VerificationAction.Reject,\r\n      '      thus making the authentication fail. This is e.Action's default value\r\n      '      when the server certificate isn't valid.\r\n      '\r\n      '  2) Set e.Flags to less restrictive criterion and ask the library to\r\n      '      validate the certificate again by setting e.Action to\r\n      '      VerificationAction.VerifyAgain.\r\n      '\r\n      '  3) Force the library to accept this certificate by setting e.Action to\r\n      '      VerificationAction.Accept.\r\n      '\r\n      ' We'll do #1 or #3, depending on the user's answer.\r\n\r\n      Console.WriteLine(\"Do you want to accept this certificate anyway? [Y/N]\")\r\n\r\n      Dim answer As Integer = Console.Read()\r\n      If (answer = AscW(\"y\"c)) OrElse (answer = AscW(\"Y\"c)) Then\r\n        e.Action = VerificationAction.Accept\r\n      End If\r\n    Else\r\n      ' e.Action's default value is VerificationAction.Accept\r\n      Console.WriteLine(\"Valid certificate received from server.\")\r\n    End If\r\n  End Sub\n"})})})]})]}),"\n",(0,i.jsx)(t.h2,{id:"client-certificates",children:"Client Certificates"}),"\n",(0,i.jsx)(t.p,{children:"Some FTP servers are configured to require the client to supply a client certificate when connecting using SSL/TLS.  Unfortunately, there is no way to know the requirement before making a connection. The FTP server administrator must communicate this requirement to you. The administrator will also provide you with the certificate that must be sent to the server when connection."}),"\n",(0,i.jsxs)(t.p,{children:["The .NET framework exposes certificates using the %System.Security.Cryptography.X509Certificates.X509Certificate2% class. The FTP component wraps this class into the ",(0,i.jsx)(t.code,{children:"Certificate"})," class. The class can load X509 certificate files encoded in the DER or Base64 encoding. Most certificate files are encrypted and require a password, often called the private key, to decode them."]}),"\n",(0,i.jsx)(t.p,{children:"The .NET framework also supports the PKCS #7 file format with the %System.Security.Cryptography.Pkcs.SignedCms% class. In that case, however, a certificate file might contain more than one certificate so care will need to be taken when handling such files."}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Example: Client certificate from an encrypted DER file"}),(0,i.jsxs)(t.p,{children:["The following example shows the use of the ",(0,i.jsx)(t.code,{children:"CertificateRequired"})," Event to supply a client certificate when the server requires one."]}),(0,i.jsxs)(c.A,{children:[(0,i.jsx)(a.A,{value:"csharp",label:"C#",default:!0,children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'    static void ClientCertificateExample()\r\n    {\r\n      try\r\n      {\r\n        FtpClient ftp = new FtpClient();\r\n        //ftp.TraceWriter = Console.Out;\r\n\r\n        // Subscribe to the CertificateReceived event\r\n        ftp.CertificateReceived += new CertificateReceivedEventHandler( OnCertificateReceived );\r\n\r\n        // Subscribe to the CertificateRequired event\r\n        ftp.CertificateRequired += new CertificateRequiredEventHandler( OnCertificateRequired );\r\n\r\n        // Connect to the server normally, unencrypted, at the usual ftp port\r\n        ftp.Connect( "localhost", 21 );\r\n\r\n        try\r\n        {\r\n          // Pick an authentication method\r\n          AuthenticationMethod authenticationMethod = AuthenticationMethod.Ssl;\r\n\r\n          // Pick verification flags. If unsure, pick \'None\'.\r\n          VerificationFlags verificationFlags = VerificationFlags.None;\r\n\r\n          /* In this example, we will not provide a client certificate at Connect(). Instead,\r\n          * we subscribe to the CertificateRequired event and if the FTP server asks us for\r\n          * a certificate, we will provide one at that time. \r\n          * \r\n          * That way, if the server is not configured to expect a certificate, it \r\n          * won\'t receive one for no reason. */\r\n\r\n          // The client certificate to submit to the server\r\n          Certificate clientCertificate = null;\r\n\r\n          // Decide if the data channel (for file transfers) will be encrypted or not\r\n          DataChannelProtection dataChannelProtection = DataChannelProtection.Private;\r\n\r\n          // Authenticate and encrypt the connection\r\n          ftp.Authenticate( authenticationMethod, verificationFlags, clientCertificate, dataChannelProtection );\r\n\r\n          // Login. The exchanged information will be encrypted\r\n          ftp.Login( "username", "password" );\r\n\r\n          /* Perform your file transfers */\r\n        }\r\n        finally\r\n        {\r\n          // Make sure we always disconnect\r\n          ftp.Disconnect();\r\n\r\n          ftp.CertificateRequired -= new CertificateRequiredEventHandler( OnCertificateRequired );\r\n          ftp.CertificateReceived -= new CertificateReceivedEventHandler( OnCertificateReceived );\r\n        }\r\n      }\r\n      catch( Exception exception )\r\n      {\r\n        // Output some information about it\r\n        Console.WriteLine( "--\x3e{0}: {1}\\n{2}", exception.GetType().Name, exception.Message, exception.StackTrace );\r\n\r\n        // Fetch the inner exception\r\n        exception = exception.InnerException;\r\n\r\n        // While there is an exception\r\n        while( exception != null )\r\n        {\r\n          // Output some information about it\r\n          Console.WriteLine( "--\x3eInner exception: {0}: {1}\\n{2}", exception.GetType().Name, exception.Message, exception.StackTrace );\r\n\r\n          // Fetch the inner exception\r\n          exception = exception.InnerException;\r\n        }\r\n      }\r\n    }\r\n\r\n    static void OnCertificateRequired( object sender, CertificateRequiredEventArgs e )\r\n    {\r\n      try\r\n      {\r\n        /* The .NET framework exposes certificates using the X509Certificate2 class.\r\n        * The FTP component wraps this class into the Certificate class.\r\n        * The class can load X509 certificate files encoded in the DER or Base64 encoding.\r\n        * Most certificate files are encrypted and require a password, often called\r\n        * the private key, to decode them. */\r\n\r\n        // Load a certificate file to submit to the server\r\n        Certificate clientCertificate = new Certificate( @"D:\\Xceed\\MyX509Certificate.der", "certificate password" );\r\n\r\n        e.Certificate = clientCertificate;\r\n      }\r\n      catch( System.Security.Cryptography.CryptographicException )\r\n      {\r\n        // Trigger failure by not providing a certificate\r\n        e.Certificate = null;\r\n      }\r\n    }\r\n\r\n    static void OnCertificateReceived( object sender, CertificateReceivedEventArgs e )\r\n    {\r\n      // Always accept the certificate\r\n      e.Action = VerificationAction.Accept;\r\n    }\n'})})}),(0,i.jsx)(a.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-vb.NET",children:"    Private Shared Sub ClientCertificateExample()\r\n      Try\r\n        Dim ftp As New FtpClient()\r\n        'ftp.TraceWriter = Console.Out;\r\n\r\n        ' Subscribe to the CertificateReceived event\r\n        AddHandler ftp.CertificateReceived, AddressOf OnCertificateReceived\r\n\r\n        ' Subscribe to the CertificateRequired event\r\n        AddHandler ftp.CertificateRequired, AddressOf OnCertificateRequired\r\n\r\n        ' Connect to the server normally, unencrypted, at the usual ftp port\r\n        ftp.Connect(\"localhost\", 21)\r\n\r\n        Try\r\n          ' Pick an authentication method\r\n          Dim authenticationMethod As AuthenticationMethod = AuthenticationMethod.Ssl\r\n\r\n          ' Pick verification flags. If unsure, pick 'None'.\r\n          Dim verificationFlags As VerificationFlags = VerificationFlags.None\r\n\r\n'           In this example, we will not provide a client certificate at Connect(). Instead,\r\n'           * we subscribe to the CertificateRequired event and if the FTP server asks us for\r\n'           * a certificate, we will provide one at that time. \r\n'           * \r\n'           * That way, if the server is not configured to expect a certificate, it \r\n'           * won't receive one for no reason. \r\n\r\n          ' The client certificate to submit to the server\r\n          Dim clientCertificate As Certificate = Nothing\r\n\r\n          ' Decide if the data channel (for file transfers) will be encrypted or not\r\n          Dim dataChannelProtection As DataChannelProtection = DataChannelProtection.Private\r\n\r\n          ' Authenticate and encrypt the connection\r\n          ftp.Authenticate(authenticationMethod, verificationFlags, clientCertificate, dataChannelProtection)\r\n\r\n          ' Login. The exchanged information will be encrypted\r\n          ftp.Login(\"username\", \"password\")\r\n\r\n          ' Perform your file transfers \r\n        Finally\r\n          ' Make sure we always disconnect\r\n          ftp.Disconnect()\r\n\r\n          RemoveHandler ftp.CertificateRequired, AddressOf OnCertificateRequired\r\n          RemoveHandler ftp.CertificateReceived, AddressOf OnCertificateReceived\r\n        End Try\r\n      Catch exception As Exception\r\n        ' Output some information about it\r\n        Console.WriteLine(\"--\x3e{0}: {1}\" & Constants.vbLf & \"{2}\", exception.GetType().Name, exception.Message, exception.StackTrace)\r\n\r\n        ' Fetch the inner exception\r\n        exception = exception.InnerException\r\n\r\n        ' While there is an exception\r\n        Do While exception IsNot Nothing\r\n          ' Output some information about it\r\n          Console.WriteLine(\"--\x3eInner exception: {0}: {1}\" & Constants.vbLf & \"{2}\", exception.GetType().Name, exception.Message, exception.StackTrace)\r\n\r\n          ' Fetch the inner exception\r\n          exception = exception.InnerException\r\n        Loop\r\n      End Try\r\n    End Sub\r\n\r\n    Private Shared Sub OnCertificateRequired(ByVal sender As Object, ByVal e As CertificateRequiredEventArgs)\r\n      Try\r\n'         The.NET framework exposes certificates using the X509Certificate2 class.\r\n'         * The FTP component wraps this class into the Certificate class.\r\n'         * The class can load X509 certificate files encoded in the DER or Base64 encoding.\r\n'         * Most certificate files are encrypted and require a password, often called\r\n'         * the private key, to decode them. \r\n\r\n        ' Load a certificate file to submit to the server\r\n        Dim clientCertificate As New Certificate(\"D:\\Xceed\\MyX509Certificate.der\", \"certificate password\")\r\n\r\n        e.Certificate = clientCertificate\r\n      Catch e1 As System.Security.Cryptography.CryptographicException\r\n        ' Trigger failure by not providing a certificate\r\n        e.Certificate = Nothing\r\n      End Try\r\n    End Sub\r\n\r\n    Private Shared Sub OnCertificateReceived(ByVal sender As Object, ByVal e As CertificateReceivedEventArgs)\r\n      ' Always accept the certificate\r\n      e.Action = VerificationAction.Accept\r\n    End Sub\n"})})})]})]}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:"Example: Client certificate from a PKCS #7 file"}),(0,i.jsxs)(t.p,{children:["Finally, this example shows the usage of the ",(0,i.jsx)(t.code,{children:"System.Security.Cryptography.Pkcs.SignedCms "})," class to select a single certificate from a PKCS #7 file."]}),(0,i.jsxs)(c.A,{children:[(0,i.jsx)(a.A,{value:"csharp",label:"C#",default:!0,children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'    static void ClientCertificateExample()\r\n    {\r\n      try\r\n      {\r\n        // Load the certificate file into a byte array\r\n        byte[] certificateBytes = File.ReadAllBytes( @"D:\\Xceed\\PKCS7Certificates.p7b" );\r\n\r\n        // Create an object that can decode the certificate data\r\n        System.Security.Cryptography.Pkcs.SignedCms cms = new System.Security.Cryptography.Pkcs.SignedCms();\r\n        \r\n        // Decode the certificates\r\n        cms.Decode( certificateBytes );\r\n\r\n        FtpClient ftp = new FtpClient();\r\n        //ftp.TraceWriter = Console.Out;\r\n\r\n        string host = "localhost";\r\n        int port = 990;\r\n\r\n        // Pick an authentication method\r\n        AuthenticationMethod authenticationMethod = AuthenticationMethod.Ssl;\r\n\r\n        // Pick verification flags. If unsure, pick \'None\'.\r\n        VerificationFlags verificationFlags = VerificationFlags.None;\r\n\r\n        // The client certificate to submit to the server\r\n        Certificate clientCertificate = null;\r\n\r\n        // Subscribe to the CertificateReceived event\r\n        ftp.CertificateReceived += new CertificateReceivedEventHandler( OnCertificateReceived );\r\n\r\n        /* A PKCS #7 file can contain more than one certificate. The certificates are in the collection\r\n        * specified in the cms.Certificates property.\r\n        * \r\n        * If you know which certificate the FTP server is waiting for, simply supply it to\r\n        * the Connect() method. If you do not know which is the correct one, you can try to connect\r\n        * using each one in turn until the server accepts one. */\r\n        \r\n        // Go through each certificate in the collection\r\n        foreach( System.Security.Cryptography.X509Certificates.X509Certificate2 x509certificate in cms.Certificates )\r\n        {\r\n          // Create a client certificate out of the current x509 certificate\r\n          clientCertificate = new Certificate( x509certificate );\r\n\r\n          try\r\n          {\r\n            // Connect implicitly to the server using encryption.\r\n            // This form always enables encryption for the data channel (for file transfers)\r\n            ftp.Connect( host, port, authenticationMethod, verificationFlags, clientCertificate );\r\n          }\r\n          catch( FtpSslException )\r\n          {\r\n            // An FtpSslException exception will be thrown if the client certificate is rejected\r\n          }\r\n\r\n          // If we connected successfully to the server\r\n          if( ftp.Connected )\r\n          {\r\n            // No need to try again\r\n            break;\r\n          }\r\n        }\r\n\r\n        try\r\n        {\r\n          // Login. The exchanged information will be encrypted\r\n          ftp.Login( "username", "password" );\r\n\r\n          /* Perform your file transfers */\r\n        }\r\n        finally\r\n        {\r\n          // Make sure we always disconnect\r\n          ftp.Disconnect();\r\n\r\n          ftp.CertificateReceived -= new CertificateReceivedEventHandler( OnCertificateReceived );\r\n        }\r\n      }\r\n      catch( Exception exception )\r\n      {\r\n        // Output some information about it\r\n        Console.WriteLine( "--\x3e{0}: {1}\\n{2}", exception.GetType().Name, exception.Message, exception.StackTrace );\r\n\r\n        // Fetch the inner exception\r\n        exception = exception.InnerException;\r\n\r\n        // While there is an exception\r\n        while( exception != null )\r\n        {\r\n          // Output some information about it\r\n          Console.WriteLine( "--\x3eInner exception: {0}: {1}\\n{2}", exception.GetType().Name, exception.Message, exception.StackTrace );\r\n\r\n          // Fetch the inner exception\r\n          exception = exception.InnerException;\r\n        }\r\n      }\r\n    }\r\n\r\n    static void OnCertificateReceived( object sender, CertificateReceivedEventArgs e )\r\n    {\r\n      // Always accept the certificate\r\n      e.Action = VerificationAction.Accept;\r\n    }\n'})})}),(0,i.jsx)(a.A,{value:"vb.net",label:"Visual Basic .NET",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-vb.NET",children:"    Private Shared Sub ClientCertificateExample()\r\n      Try\r\n        ' Load the certificate file into a byte array\r\n        Dim certificateBytes() As Byte = File.ReadAllBytes(\"D:\\Xceed\\PKCS7Certificates.p7b\")\r\n\r\n        ' Create an object that can decode the certificate data\r\n        Dim cms As New System.Security.Cryptography.Pkcs.SignedCms()\r\n\r\n        ' Decode the certificates\r\n        cms.Decode(certificateBytes)\r\n\r\n        Dim ftp As New FtpClient()\r\n        'ftp.TraceWriter = Console.Out;\r\n\r\n        Dim host As String = \"localhost\"\r\n        Dim port As Integer = 990\r\n\r\n        ' Pick an authentication method\r\n        Dim authenticationMethod As AuthenticationMethod = AuthenticationMethod.Ssl\r\n\r\n        ' Pick verification flags. If unsure, pick 'None'.\r\n        Dim verificationFlags As VerificationFlags = VerificationFlags.None\r\n\r\n        ' The client certificate to submit to the server\r\n        Dim clientCertificate As Certificate = Nothing\r\n\r\n        ' Subscribe to the CertificateReceived event\r\n        AddHandler ftp.CertificateReceived, AddressOf OnCertificateReceived\r\n\r\n'         A PKCS #7 file can contain more than one certificate. The certificates are in the collection\r\n'         * specified in the cms.Certificates property.\r\n'         * \r\n'         * If you know which certificate the FTP server is waiting for, simply supply it to\r\n'         * the Connect() method. If you do not know which is the correct one, you can try to connect\r\n'         * using each one in turn until the server accepts one. \r\n\r\n        ' Go through each certificate in the collection\r\n        For Each x509certificate As System.Security.Cryptography.X509Certificates.X509Certificate2 In cms.Certificates\r\n          ' Create a client certificate out of the current x509 certificate\r\n          clientCertificate = New Certificate(x509certificate)\r\n\r\n          Try\r\n            ' Connect implicitly to the server using encryption.\r\n            ' This form always enables encryption for the data channel (for file transfers)\r\n            ftp.Connect(host, port, authenticationMethod, verificationFlags, clientCertificate)\r\n          Catch e1 As FtpSslException\r\n            ' An FtpSslException exception will be thrown if the client certificate is rejected\r\n          End Try\r\n\r\n          ' If we connected successfully to the server\r\n          If ftp.Connected Then\r\n            ' No need to try again\r\n            Exit For\r\n          End If\r\n        Next x509certificate\r\n\r\n        Try\r\n          ' Login. The exchanged information will be encrypted\r\n          ftp.Login(\"username\", \"password\")\r\n\r\n          ' Perform your file transfers \r\n        Finally\r\n          ' Make sure we always disconnect\r\n          ftp.Disconnect()\r\n\r\n          RemoveHandler ftp.CertificateReceived, AddressOf OnCertificateReceived\r\n        End Try\r\n      Catch exception As Exception\r\n        ' Output some information about it\r\n        Console.WriteLine(\"--\x3e{0}: {1}\" & Constants.vbLf & \"{2}\", exception.GetType().Name, exception.Message, exception.StackTrace)\r\n\r\n        ' Fetch the inner exception\r\n        exception = exception.InnerException\r\n\r\n        ' While there is an exception\r\n        Do While exception IsNot Nothing\r\n          ' Output some information about it\r\n          Console.WriteLine(\"--\x3eInner exception: {0}: {1}\" & Constants.vbLf & \"{2}\", exception.GetType().Name, exception.Message, exception.StackTrace)\r\n\r\n          ' Fetch the inner exception\r\n          exception = exception.InnerException\r\n        Loop\r\n      End Try\r\n    End Sub\r\n\r\n    Private Shared Sub OnCertificateReceived(ByVal sender As Object, ByVal e As CertificateReceivedEventArgs)\r\n      ' Always accept the certificate\r\n      e.Action = VerificationAction.Accept\r\n    End Sub\n"})})})]})]})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},19365:(e,t,n)=>{n.d(t,{A:()=>a});n(96540);var i=n(34164);const r={tabItem:"tabItem_Ymn6"};var c=n(74848);function a(e){let{children:t,hidden:n,className:a}=e;return(0,c.jsx)("div",{role:"tabpanel",className:(0,i.A)(r.tabItem,a),hidden:n,children:t})}},11470:(e,t,n)=>{n.d(t,{A:()=>S});var i=n(96540),r=n(34164),c=n(23104),a=n(56347),o=n(205),s=n(57485),l=n(31682),f=n(70679);function h(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function d(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:i,default:r}}=e;return{value:t,label:n,attributes:i,default:r}}))}(n);return function(e){const t=(0,l.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function u(e){let{queryString:t=!1,groupId:n}=e;const r=(0,a.W6)(),c=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s.aZ)(c),(0,i.useCallback)((e=>{if(!c)return;const t=new URLSearchParams(r.location.search);t.set(c,e),r.replace({...r.location,search:t.toString()})}),[c,r])]}function v(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,c=d(e),[a,s]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const i=n.find((e=>e.default))??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:t,tabValues:c}))),[l,h]=u({queryString:n,groupId:r}),[v,m]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,c]=(0,f.Dv)(n);return[r,(0,i.useCallback)((e=>{n&&c.set(e)}),[n,c])]}({groupId:r}),x=(()=>{const e=l??v;return p({value:e,tabValues:c})?e:null})();(0,o.A)((()=>{x&&s(x)}),[x]);return{selectedValue:a,selectValue:(0,i.useCallback)((e=>{if(!p({value:e,tabValues:c}))throw new Error(`Can't select invalid tab value=${e}`);s(e),h(e),m(e)}),[h,m,c]),tabValues:c}}var m=n(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var C=n(74848);function y(e){let{className:t,block:n,selectedValue:i,selectValue:a,tabValues:o}=e;const s=[],{blockElementScrollPositionUntilNextRender:l}=(0,c.a_)(),f=e=>{const t=e.currentTarget,n=s.indexOf(t),r=o[n].value;r!==i&&(l(t),a(r))},h=e=>{let t=null;switch(e.key){case"Enter":f(e);break;case"ArrowRight":{const n=s.indexOf(e.currentTarget)+1;t=s[n]??s[0];break}case"ArrowLeft":{const n=s.indexOf(e.currentTarget)-1;t=s[n]??s[s.length-1];break}}t?.focus()};return(0,C.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},t),children:o.map((e=>{let{value:t,label:n,attributes:c}=e;return(0,C.jsx)("li",{role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,ref:e=>s.push(e),onKeyDown:h,onClick:f,...c,className:(0,r.A)("tabs__item",x.tabItem,c?.className,{"tabs__item--active":i===t}),children:n??t},t)}))})}function g(e){let{lazy:t,children:n,selectedValue:c}=e;const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===c));return e?(0,i.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,C.jsx)("div",{className:"margin-top--md",children:a.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==c})))})}function b(e){const t=v(e);return(0,C.jsxs)("div",{className:(0,r.A)("tabs-container",x.tabList),children:[(0,C.jsx)(y,{...t,...e}),(0,C.jsx)(g,{...t,...e})]})}function S(e){const t=(0,m.A)();return(0,C.jsx)(b,{...e,children:h(e.children)},String(t))}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(96540);const r={},c=i.createContext(r);function a(e){const t=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(c.Provider,{value:t},e.children)}}}]);